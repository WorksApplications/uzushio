<!doctype html>
<html lang="ja">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta http-equiv="Content-Language" content="ja" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>perlfaq4 - データ操作 - perldoc.jp</title>
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="Content-Script-Type" content="text/javascript" />
    <meta name="description" content="データ操作" />
    <meta name="keywords" content="Perl,翻訳,モジュール">

    <link href="/static/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />

    <link href="/static/css/print.css" media="print" rel="stylesheet" type="text/css" />
    <!--[if IE]>
    <link href="/static/css/ie.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <![endif]-->

    <link rel="shortcut icon" href="/favicon.ico" />
    <script src="/static/prettify/prettify.js" type="text/javascript"></script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>

    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" />
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-59935-4']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>
<body onload="prettyPrint();return true;">
<div class="container">
    <div class="header span-24 last">
        <a class="SiteLogo" href="/">perldoc.jp</a>
    </div>
    <div class="nav span-24 last">
        <ul>
            <li><a href="/">トップ</a></li>
            <li><a href="/index/core">本体</a></li>
            <li><a href="/index/function">関数</a></li>
            <li><a href="/index/variable">変数</a></li>
            <li><a href="/index/module">モジュール</a></li>
            <li><a href="/category">カテゴリ別</a></li>
            <li><a href="/index/article">その他の翻訳</a></li>
            <li><a href="/translators">翻訳者</a></li>
            <li><a href="/manners">翻訳の作法</a></li>
            <li><a href="/about">このサイトについて</a></li>
        </ul>

        <!-- SiteSearch Google -->
        <form method=get action="http://www.google.co.jp/search" id="GoogleSearch">
            <input type=text name=q size=31 maxlength=255 value="">
            <input type=hidden name=ie value=UTF-8>
            <input type=hidden name=oe value=UTF-8>
            <input type=hidden name=hl value="ja">
            <input type=hidden name=domains value="perldoc.jp">
            <input type="hidden" name="sitesearch" value="perldoc.jp">
            <input type=submit name=btnG value="Google 検索">
        </form>
        <!-- SiteSearch Google -->
    </div>
    <div id="main" class="span-24 last">
        <div id="content">

            <div class="content">
                <div class="PodPage">


                    <div class="PodInfo">
                        <div class="PodVersion">5.10.1</div>

                        <div class="CheckAtCPAN"><a href="http://search.cpan.org/perldoc?perlfaq4">CPANで確認する</a></div>


                        <div class="OtherVersions">
                            Other versions:<br />


                            <a href="/docs/modules/perlfaq-5.0150039/perlfaq4.pod">perlfaq-5.0150039</a><br />

                            <a href="/docs/perl/5.14.1/perlfaq4.pod">5.14.1</a><br />

                            <a href="/docs/perl/5.12.1/perlfaq4.pod">5.12.1</a><br />

                            <a href="/docs/perl/5.10.0/perlfaq4.pod">5.10.0</a><br />

                            <a href="/docs/perl/5.6.1/perlfaq4.pod">5.6.1</a><br />



                        </div><form action="/docs/perl/5.10.1/perlfaq4.pod/diff">
                        <select name="target"><option value="modules/perlfaq-5.0150039/perlfaq4.pod">5.0150039</option><option value="perl/5.14.1/perlfaq4.pod">5.14.1</option><option value="perl/5.12.1/perlfaq4.pod">5.12.1</option><option value="perl/5.10.0/perlfaq4.pod">5.10.0</option><option value="perl/5.6.1/perlfaq4.pod">5.6.1</option></select>
                        <input type="submit" value="diff" />
                    </form>



                        <div class="Source"><a href="http://perldoc.jp/docs/perl/5.10.1/perlfaq4.pod.pod">Source</a></div>


                        <div><a target="_blank"  href="http://sourceforge.jp/cvs/view/perldocjp/docs/perl/5.10.1/perlfaq4.pod?view=log">CVS log on sf.jp</a></div>


                        <script>
                            var display_original = false;
                        </script>
                        <div>
                            <a href="#" onclick="$('.original').css('display', display_original ? 'none' : 'block'); display_original = display_original ? false : true; return false;">原文を表示/隠す</a>
                        </div>

                    </div>



                    <div class="PodBody">
                        <ul class="pod_toc">
                            <li><a href="#NAME">名前</a></li>
                            <li><a href="#DESCRIPTION">説明</a></li>
                            <li><a href="#Data:32Numbers">データ: 数</a>
                                <ul>
                                    <li><a href="#Why32am32I32getting32long32decimals32eg4419.949999999999941instead32of32the32numbers32I32should32be32getting32eg4419.9541">なぜ 19.95 のような数字ではなく、19.9499999999999 のような長い数字が出てきたんでしょうか?</a></li>
                                    <li><a href="#Why32is32int40broken63">なぜ int() は壊れているのでしょう?</a></li>
                                    <li><a href="#Why32isnt32my32octal32data32interpreted32correctly63">なぜ私の 8 進データは正しく解釈されないのでしょうか?</a></li>
                                    <li><a href="#Does32Perl32have32a32round40function63What32about32ceil40and32floor40Trig32functions63">Perl には丸め関数がありますか? ceil() と floor() とは何ですか? 三角関数は?</a></li>
                                    <li><a href="#How32do32I32convert32between32numeric32representations47bases47radixes63">数値表現や基底や基数を変換するには?</a></li>
                                    <li><a href="#Why32doesnt32work32the32way32I32want32it32to63">なぜ & は私の思った通りに動作しないのでしょうか?</a></li>
                                    <li><a href="#How32do32I32multiply32matrices63">行列の積を計算するには?</a></li>
                                    <li><a href="#How32do32I32perform32an32operation32on32a32series32of32integers63">整数値の並びに対してある操作を実行するには?</a></li>
                                    <li><a href="#How32can32I32output32Roman32numerals63">ローマ数字を出力するには?</a></li>
                                    <li><a href="#Why32arent32my32random32numbers32random63">なぜ私の乱数はランダムでないの?</a></li>
                                    <li><a href="#How32do32I32get32a32random32number32between32X32and32Y63">X と Y の間の乱数を得るには?</a></li>
                                </ul>
                            </li>
                            <li><a href="#Data:32Dates">データ:日付</a>
                                <ul>
                                    <li><a href="#How32do32I32find32the32day32or32week32of32the32year63">その年の何日目であるかを知るには?</a></li>
                                    <li><a href="#How32do32I32find32the32current32century32or32millennium63">現在の世紀や千年紀を知るには?</a></li>
                                    <li><a href="#How32can32I32compare32two32dates32and32find32the32difference63">二つの日付文字列を比較するには?</a></li>
                                    <li><a href="#How32can32I32take32a32string32and32turn32it32into32epoch32seconds63">文字列を受け取って、それを紀元からの経過秒数に変換するには?</a></li>
                                    <li><a href="#How32can32I32find32the32Julian32Day63">ユリウス日を求めるには?</a></li>
                                    <li><a href="#How32do32I32find32yesterdays32date63">昨日の日付を得るには?</a></li>
                                    <li><a href="#Does32Perl32have32a32Year32200032problem63Is32Perl32Y2K32compliant63">Perl には 2000 年問題があるのですか? Perl は 2000 年対応ですか?</a></li>
                                </ul>
                            </li>
                            <li><a href="#Data:32Strings">データ: 文字列</a>
                                <ul>
                                    <li><a href="#How32do32I32validate32input63">入力を検査するには?</a></li>
                                    <li><a href="#How32do32I32unescape32a32string63">文字列のアンエスケープ (unescape)をするには?</a></li>
                                    <li><a href="#How32do32I32remove32consecutive32pairs32of32characters63">キャラクタの連続した組を取り除くには?</a></li>
                                    <li><a href="#How32do32I32expand32function32calls32in32a32string63">文字列中にある関数呼び出しを展開するには?</a></li>
                                    <li><a href="#How32do32I32find32matching47nesting32anything63">何かがマッチしている/ネストしているということを検出するには?</a></li>
                                    <li><a href="#How32do32I32reverse32a32string63">文字列をひっくり返すには?</a></li>
                                    <li><a href="#How32do32I32expand32tabs32in32a32string63">文字列中にあるタブを展開するには?</a></li>
                                    <li><a href="#How32do32I32reformat32a32paragraph63">段落を整形するには?</a></li>
                                    <li><a href="#How32can32I32access32or32change32N32characters32of32a32string63">文字列の最初の N 文字にアクセスしたり、それを変更するには?</a></li>
                                    <li><a href="#How32do32I32change32the32Nth32occurrence32of32something63">何かの N 番目のものを変更するには?</a></li>
                                    <li><a href="#How32can32I32count32the32number32of32occurrences32of32a32substring32within32a32string63">ある文字列の中に存在する部分文字列が何個あるのかを数えるには?</a></li>
                                    <li><a href="#Does32Perl32have32a32Year32203832problem63">Perl には 2038 年問題はありますか?</a></li>
                                    <li><a href="#How32do32I32capitalize32all32the32words32on32one32line63">一行にあるすべての単語をキャピタライズするには?</a></li>
                                    <li><a href="#How32can32I32split32a32character93delimited32string32except32when32inside32character93">(とある文字)の内側にある時を除き、(とある文字)で終端されている文字列を分割するには?</a></li>
                                    <li><a href="#How32do32I32strip32blank32space32from32the32beginning47end32of32a32string63">文字列の先頭や末尾にある空白を剥ぎ取るには?</a></li>
                                    <li><a href="#How32do32I32pad32a32string32with32blanks32or32pad32a32number32with32zeroes63">文字列に空白をパッディングしたり、数値にゼロをパッディングしたりするには?</a></li>
                                    <li><a href="#How32do32I32extract32selected32columns32from32a32string63">文字列から選択されたカラムを取り出すには?</a></li>
                                    <li><a href="#How32do32I32find32the32soundex32value32of32a32string63">文字列の soundex 値を見つけるには?</a></li>
                                    <li><a href="#How32can32I32expand32variables32in32text32strings63">テキスト文字列の中にある変数を展開するには?</a></li>
                                    <li><a href="#Whats32wrong32with32always32quoting32vars63">常にクォーティング "$vars" することの何が悪いの?</a></li>
                                    <li><a href="#Why32dont32my32HERE32documents32work63">なぜ私の <<HERE ドキュメントがうまく動かないのでしょう?</a></li>
                                </ul>
                            </li>
                            <li><a href="#Data:32Arrays">データ: 配列</a>
                                <ul>
                                    <li><a href="#What32is32the32difference32between32a32list32and32an32array63">リストと配列の差とはなんですか?</a></li>
                                    <li><a href="#What32is32the32difference32between32array91193and32array91193">$array[1] と @array[1] との間の違いはなんですか?</a></li>
                                    <li><a href="#How32can32I32remove32duplicate32elements32from32a32list32or32array63">配列やリストにある重複した要素を削除するには?</a></li>
                                    <li><a href="#How32can32I32tell32whether32a32certain32element32is32contained32in32a32list32or32array63">リストや配列の内容にある特定の要素があるかどうかを確かめるには?</a></li>
                                    <li><a href="#How32do32I32compute32the32difference32of32two32arrays63How32do32I32compute32the32intersection32of32two32arrays63">二つの配列の差(difference)を求めるには? 二つの配列の共通要素(inter section)を求めるには?</a></li>
                                    <li><a href="#How32do32I32test32whether32two32arrays32or32hashes32are32equal63">二つの配列や二つのハッシュが等しいかどうかを検査するには?</a></li>
                                    <li><a href="#How32do32I32find32the32first32array32element32for32which32a32condition32is32true63">ある条件が真となる最初の配列要素を見つけだすには?</a></li>
                                    <li><a href="#How32do32I32handle32linked32lists63">リンク付きリストを扱うには?</a></li>
                                    <li><a href="#How32do32I32handle32circular32lists63">循環リストを扱うには?</a></li>
                                    <li><a href="#How32do32I32shuffle32an32array32randomly63">配列をランダムにかき混ぜるには?</a></li>
                                    <li><a href="#How32do32I32process47modify32each32element32of32an32array63">配列の各要素に対する処理や、変更を行うには?</a></li>
                                    <li><a href="#How32do32I32select32a32random32element32from32an32array63">ある配列からランダムに要素を選択するには?</a></li>
                                    <li><a href="#How32do32I32permute32N32elements32of32a32list63">N 要素を持つリストの順列(permute)を求めるには?</a></li>
                                    <li><a href="#How32do32I32sort32an32array32by32anything41">(なにか)で配列をソートするには?</a></li>
                                    <li><a href="#How32do32I32manipulate32arrays32of32bits63">ビット配列を扱うには?</a></li>
                                    <li><a href="#Why32does32defined40return32true32on32empty32arrays32and32hashes63">なぜ空の配列やハッシュに defined() を使ったときに真が返ってくるのでしょう?</a></li>
                                </ul>
                            </li>
                            <li><a href="#Data:32Hashes32Associative32Arrays41">データ: ハッシュ(連想配列)</a>
                                <ul>
                                    <li><a href="#How32do32I32process32an32entire32hash63">ハッシュ全体を処理するには?</a></li>
                                    <li><a href="#How32do32I32merge32two32hashes63">二つのハッシュをマージするには?</a></li>
                                    <li><a href="#What32happens32if32I32add32or32remove32keys32from32a32hash32while32iterating32over32it63">ハッシュに対して反復操作を行っているときにキーの追加や削除をすると何が起きますか?</a></li>
                                    <li><a href="#How32do32I32look32up32a32hash32element32by32value63">ハッシュの要素をその値で検索するには?</a></li>
                                    <li><a href="#How32can32I32know32how32many32entries32are32in32a32hash63">ハッシュにどれくらいの要素があるのを知るには?</a></li>
                                    <li><a href="#How32do32I32sort32a32hash32optionally32by32value32instead32of32key41">ハッシュを(キーではなく値で)ソートするには?</a></li>
                                    <li><a href="#How32can32I32always32keep32my32hash32sorted63">私のハッシュを常にソートされた状態にしておくには?</a></li>
                                    <li><a href="#Whats32the32difference32between32delete32and32undef32with32hashes63">ハッシュに対する "delete" と "undef"との間の違いは?</a></li>
                                    <li><a href="#Why32dont32my32tied32hashes32make32the32defined47exists32distinction63">なぜわたしの tie されたハッシュは defined と exists を区別しないのでしょうか?</a></li>
                                    <li><a href="#How32do32I32reset32an32each40operation32part-way32through63">each() 操作の途中でリセットしてしまうには?</a></li>
                                    <li><a href="#How32can32I32get32the32unique32keys32from32two32hashes63">二つのハッシュからユニークなキーを取りだすには?</a></li>
                                    <li><a href="#How32can32I32store32a32multidimensional32array32in32a32DBM32file63">DBM ファイルに多次元配列を格納するには?</a></li>
                                    <li><a href="#How32can32I32make32my32hash32remember32the32order32I32put32elements32into32it63">わたしのハッシュが格納した順番を覚えておくようにするには?</a></li>
                                    <li><a href="#Why32does32passing32a32subroutine32an32undefined32element32in32a32hash32create32it63">なぜあるハッシュの未定義要素をサブルーチンに渡すとそれを作成するのでしょうか?</a></li>
                                    <li><a href="#How32can32I32make32the32Perl32equivalent32of32a32C32structure47C43class47hash32or32array32of32hashes32or32arrays63">C の構造体/C++ のクラスのハッシュ、配列のハッシュ、配列と等価なものを Perl で作成するには?</a></li>
                                    <li><a href="#How32can32I32use32a32reference32as32a32hash32key63">ハッシュのキーとしてリファレンスを使うには?</a></li>
                                </ul>
                            </li>
                            <li><a href="#Data:32Misc">データ:その他</a>
                                <ul>
                                    <li><a href="#How32do32I32handle32binary32data32correctly63">バイナリデータを正しく扱うには?</a></li>
                                    <li><a href="#How32do32I32determine32whether32a32scalar32is32a32number47whole47integer47float63">あるスカラ値が数値/整数/浮動小数点数かどうかを決定するには?</a></li>
                                    <li><a href="#How32do32I32keep32persistent32data32across32program32calls63">プログラムの呼び出しの間に、データ構造を永続的に保持するには?</a></li>
                                    <li><a href="#How32do32I32print32out32or32copy32a32recursive32data32structure63">再帰的なデータ構造を出力したりコピーするには?</a></li>
                                    <li><a href="#How32do32I32define32methods32for32every32class47object63">すべてのクラス/オブジェクトのためのメソッドを定義するには?</a></li>
                                    <li><a href="#How32do32I32verify32a32credit32card32checksum63">クレジットカードのチェックサムを検査するには?</a></li>
                                    <li><a href="#How32do32I32pack32arrays32of32doubles32or32floats32for32XS32code63">XSプログラムのために倍精度実数や単精度実数の配列を pack するには?</a></li>
                                </ul>
                            </li>
                            <li><a href="#REVISION">REVISION</a></li>
                            <li><a href="#AUTHOR32AND32COPYRIGHT">AUTHOR AND COPYRIGHT</a></li>
                        </ul>

                        <div class="pod_content_body"><h1 id="NAME">名前<a href="#NAME" class="toc_link">&#182;</a></h1>

                            <div class="original">

                                <p>perlfaq4 - Data Manipulation</p>

                            </div>

                            <p>perlfaq4 - データ操作</p>

                            <h1 id="DESCRIPTION">説明<a href="#DESCRIPTION" class="toc_link">&#182;</a></h1>

                            <div class="original">

                                <p>This section of the FAQ answers questions related to manipulating numbers, dates, strings, arrays, hashes, and miscellaneous data issues.</p>

                            </div>

                            <p>FAQのこのセクションでは、数値、日付、文字列、配列、ハッシュその他の データの取り扱いに関する質問に回答しています。</p>

                            <h1 id="Data:32Numbers">データ: 数<a href="#Data:32Numbers" class="toc_link">&#182;</a></h1>

                            <p></p>

                            <h2 id="Why32am32I32getting32long32decimals32eg4419.949999999999941instead32of32the32numbers32I32should32be32getting32eg4419.9541">なぜ 19.95 のような数字ではなく、19.9499999999999 のような長い数字が出てきたんでしょうか?<a href="#Why32am32I32getting32long32decimals32eg4419.949999999999941instead32of32the32numbers32I32should32be32getting32eg4419.9541" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Internally, your computer represents floating-point numbers in binary. Digital (as in powers of two) computers cannot store all numbers exactly. Some real numbers lose precision in the process. This is a problem with how computers store numbers and affects all computer languages, not just Perl.</p>

                            </div>

                            <p>内部的には、あなたの使っているコンピュータは浮動小数点数を 2 進数を 使って表現しています。 (2 のべき乗のような) デジタルなコンピュータは全ての数値を正確に 保管することはできません。 実数は処理中に精度が落ちることがあります。 これはコンピュータがどのように数値を保管するかの問題で、Perl だけではなく 全てのコンピュータ言語に影響を与えます。</p>

                            <div class="original">

                                <p><a href="/pod/perlnumber">perlnumber</a> shows the gory details of number representations and conversions.</p>

                            </div>

                            <p><a href="/pod/perlnumber">perlnumber</a> には、数値表現と変換に関する不愉快な詳細が記されています。</p>

                            <div class="original">

                                <p>To limit the number of decimal places in your numbers, you can use the printf or sprintf function. See the <a href="/pod/perlop">&quot;Floating Point Arithmetic&quot;</a> for more details.</p>

                            </div>

                            <p>10 進数の桁数を制限するには、printf や sprintf の関数が使えます。 更なる詳細については <a href="/pod/perlop">&quot;Floating Point Arithmetic&quot;</a> を参照してください。</p>

                            <pre class="prettyprint lang-perl"><code>        printf &quot;%.2f&quot;, 10/3;

        my $number = sprintf &quot;%.2f&quot;, 10/3;</code></pre>

                            <h2 id="Why32is32int40broken63">なぜ int() は壊れているのでしょう?<a href="#Why32is32int40broken63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Your <code>int()</code> is most probably working just fine. It&#39;s the numbers that aren&#39;t quite what you think.</p>

                            </div>

                            <p><code>int()</code> はほぼ確実に正しく動作しています。 これは、数値というものがあなたの考えているものと違うからです。</p>

                            <div class="original">

                                <p>First, see the answer to &quot;Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?&quot;.</p>

                            </div>

                            <p>まず、&quot;Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?&quot; に対する答えを参照してください。</p>

                            <div class="original">

                                <p>For example, this</p>

                            </div>

                            <p>例えば、これは:</p>

                            <pre class="prettyprint lang-perl"><code>        print int(0.6/0.2-2), &quot;\n&quot;;</code></pre>

                            <div class="original">

                                <p>will in most computers print 0, not 1, because even such simple numbers as 0.6 and 0.2 cannot be presented exactly by floating-point numbers. What you think in the above as &#39;three&#39; is really more like 2.9999999999999995559.</p>

                            </div>

                            <p>ほとんどのコンピュータでは 1 ではなく 0 を表示します; 0.6 や 0.2 と言った単純な数値であっても、浮動小数点数で正確に表現できません。 さきほどあなたが &quot;3&quot; と考えたものは、実際には 2.9999999999999995559 と いったものです。</p>

                            <h2 id="Why32isnt32my32octal32data32interpreted32correctly63">なぜ私の 8 進データは正しく解釈されないのでしょうか?<a href="#Why32isnt32my32octal32data32interpreted32correctly63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>You&#39;re probably trying to convert a string to a number, which Perl only converts as a decimal number. When Perl converts a string to a number, it ignores leading spaces and zeroes, then assumes the rest of the digits are in base 10:</p>

                            </div>

                            <p>おそらく文字列を数値に変換しようとしているのでしょうが、Perl は 10 進数しか変換しません。 Perl が文字列を数値に変換するとき、先頭の空白とゼロは無視して、残りの 数字は 10 進数であると仮定します:</p>

                            <pre class="prettyprint lang-perl"><code>        my $string = &#39;0644&#39;;

        print $string + 0;  # prints 644

        print $string + 44; # prints 688, certainly not octal!</code></pre>

                            <div class="original">

                                <p>This problem usually involves one of the Perl built-ins that has the same name a unix command that uses octal numbers as arguments on the command line. In this example, <code>chmod</code> on the command line knows that its first argument is octal because that&#39;s what it does:</p>

                            </div>

                            <p>この問題は普通コマンドライン引数として 8 進数を使う同じ名前の Unix コマンドがある Perl 組み込み関数に関わります。 この例では、コマンドラインの <code>chmod</code> は、最初の引数として 8 進数を 求めているので、最初の引数が 8 進数だと分かっています:</p>

                            <pre class="prettyprint lang-perl"><code>        %prompt&gt; chmod 644 file</code></pre>

                            <div class="original">

                                <p>If you want to use the same literal digits (644) in Perl, you have to tell Perl to treat them as octal numbers either by prefixing the digits with a <code>0</code> or using <code>oct</code>:</p>

                            </div>

                            <p>もし同じリテラルの数字 (644) を Perl で使いたいなら、 先頭に <code>0</code> を付けるか <code>oct</code> を使うことで Perl にこれを 8 進数で 扱うように教える必要があります:</p>

                            <pre class="prettyprint lang-perl"><code>        chmod(     0644, $file);   # right, has leading zero
        chmod( oct(644), $file );  # also correct</code></pre>

                            <div class="original">

                                <p>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in <code>@ARGV</code>:</p>

                            </div>

                            <p>この問題は、Perl が文字列として考えているところ、例えば <code>@ARGV</code> のコマンドライン引数から数字を持ってくる場合に起こります:</p>

                            <pre class="prettyprint lang-perl"><code>        chmod( $ARGV[0],      $file);   # wrong, even if &quot;0644&quot;

        chmod( oct($ARGV[0]), $file );  # correct, treat string as octal</code></pre>

                            <div class="original">

                                <p>You can always check the value you&#39;re using by printing it in octal notation to ensure it matches what you think it should be. Print it in octal and decimal format:</p>

                            </div>

                            <p>使っている値があなたの考えている形と一致しているかを確認するために、 いつでも値を 8 進表記で表示することでチェックできます。 8 進数と 10 進数で表示します:</p>

                            <pre class="prettyprint lang-perl"><code>        printf &quot;0%o %d&quot;, $number, $number;</code></pre>

                            <h2 id="Does32Perl32have32a32round40function63What32about32ceil40and32floor40Trig32functions63">Perl には丸め関数がありますか? ceil() と floor() とは何ですか? 三角関数は?<a href="#Does32Perl32have32a32round40function63What32about32ceil40and32floor40Trig32functions63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Remember that <code>int()</code> merely truncates toward 0. For rounding to a certain number of digits, <code>sprintf()</code> or <code>printf()</code> is usually the easiest route.</p>

                            </div>

                            <p><code>int()</code> は 0 へ向かって丸めを行うことを思い出してください。 特定の桁数で丸めを行うには、<code>sprintf()</code> や <code>printf()</code> を使うことが 通常はもっとも簡単なやり方です。</p>

                            <pre class="prettyprint lang-perl"><code>        printf(&quot;%.3f&quot;, 3.1415926535);   # prints 3.142</code></pre>

                            <div class="original">

                                <p>The <code>POSIX</code> module (part of the standard Perl distribution) implements <code>ceil()</code>, <code>floor()</code>, and a number of other mathematical and trigonometric functions.</p>

                            </div>

                            <p>(標準 Perl 配布キットの一部である)<code>POSIX</code> モジュールは <code>ceil()</code>、 <code>floor()</code>、そしてその他の数学的な関数や三角関数の多くを実装しています。</p>

                            <pre class="prettyprint lang-perl"><code>        use POSIX;
        $ceil   = ceil(3.5);   # 4
        $floor  = floor(3.5);  # 3</code></pre>

                            <div class="original">

                                <p>In 5.000 to 5.003 perls, trigonometry was done in the <code>Math::Complex</code> module. With 5.004, the <code>Math::Trig</code> module (part of the standard Perl distribution) implements the trigonometric functions. Internally it uses the <code>Math::Complex</code> module and some functions can break out from the real axis into the complex plane, for example the inverse sine of 2.</p>

                            </div>

                            <p>perl の 5.000 から 5.003 では、三角関数は <code>Math::Complex</code> モジュールの中で 実行されていました。 5.004 では、<code>Math::Trig</code> モジュール(標準 Perl 配布キットの一部です)が 三角関数を実装しています。 内部的にはこれは <code>Math::Complex</code> を使っていて、一部の関数は実数値を複素数領域へ 変化させることができます。 2 の inverse sine がその一例です。</p>

                            <div class="original">

                                <p>Rounding in financial applications can have serious implications, and the rounding method used should be specified precisely. In these cases, it probably pays not to trust whichever system rounding is being used by Perl, but to instead implement the rounding function you need yourself.</p>

                            </div>

                            <p>金融に関係するアプリケーションにおいては、丸めはきちんとした実装を 必要とするかもしれません。 そして、丸めの方法は適切に使われるべきものです。 この場合、Perl が使っているシステムによる丸めを信用すべきではなく、 自分自身で丸め関数を実装するようにすべきでしょう。</p>

                            <div class="original">

                                <p>To see why, notice how you&#39;ll still have an issue on half-way-point alternation:</p>

                            </div>

                            <p>なぜかを見るために、中間点反復に関する問題があるということに注意しましょう:</p>

                            <pre class="prettyprint lang-perl"><code>        for ($i = 0; $i &lt; 1.01; $i += 0.05) { printf &quot;%.1f &quot;,$i}

        0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
        0.8 0.8 0.9 0.9 1.0 1.0</code></pre>

                            <div class="original">

                                <p>Don&#39;t blame Perl. It&#39;s the same as in C. IEEE says we have to do this. Perl numbers whose absolute values are integers under 2**31 (on 32 bit machines) will work pretty much like mathematical integers. Other numbers are not guaranteed.</p>

                            </div>

                            <p>Perl を責めないでください。 これはCでも同じことなのです。 IEEE ではこのようにすることを述べています。 Perl での数値は絶対値で 2**31(32 ビットマシンの場合)以下の場合の整数値であれば 数学的な整数と同じように振る舞います。 それ以外の数値は恩恵を受けません。</p>

                            <h2 id="How32do32I32convert32between32numeric32representations47bases47radixes63">数値表現や基底や基数を変換するには?<a href="#How32do32I32convert32between32numeric32representations47bases47radixes63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</p>

                            </div>

                            <p>Perl ではいつものことですが、これを行うには複数の方法があります。 以下は、一般的な数値表現の変換を行うための手法のいくつかの例です。 これは完全性よりも説明性を意図しています。</p>

                            <div class="original">

                                <p>Some of the examples later in <a href="/pod/perlfaq4">perlfaq4</a> use the <code>Bit::Vector</code> module from CPAN. The reason you might choose <code>Bit::Vector</code> over the perl built in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</p>

                            </div>

                            <p><a href="/pod/perlfaq4">perlfaq4</a> の後の方での例では CPAN にある <code>Bit::Vector</code> を使っています。 perl 組み込みの関数よりも <code>Bit::Vector</code> を選択する理由は、 どんな大きさの数でも動作し、いくつかの操作では速度のために最適化されていて、 少なくともいくらかのプログラマにとっては表記がわかりやすいからです。</p>

                            <dl>

                                <dt>How do I convert hexadecimal into decimal</dt>
                                <dd>

                                    <p>(16 進数を 10 進数に変換するには?)</p>

                                    <div class="original">

                                        <p>Using perl&#39;s built in conversion of <code>0x</code> notation:</p>

                                    </div>

                                    <p><code>0x</code> 表記による perl の組み込み変換を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $dec = 0xDEADBEEF;</code></pre>

                                    <div class="original">

                                        <p>Using the <code>hex</code> function:</p>

                                    </div>

                                    <p><code>hex</code> 関数を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $dec = hex(&quot;DEADBEEF&quot;);</code></pre>

                                    <div class="original">

                                        <p>Using <code>pack</code>:</p>

                                    </div>

                                    <p><code>pack</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $dec = unpack(&quot;N&quot;, pack(&quot;H8&quot;, substr(&quot;0&quot; x 8 . &quot;DEADBEEF&quot;, -8)));</code></pre>

                                    <div class="original">

                                        <p>Using the CPAN module <code>Bit::Vector</code>:</p>

                                    </div>

                                    <p>CPAN の <code>Bit::Vector</code> モジュールを使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        use Bit::Vector;
        $vec = Bit::Vector-&gt;new_Hex(32, &quot;DEADBEEF&quot;);
        $dec = $vec-&gt;to_Dec();</code></pre>

                                </dd>
                                <dt>How do I convert from decimal to hexadecimal</dt>
                                <dd>

                                    <p>(10 進数を 16 進数に変換するには?)</p>

                                    <div class="original">

                                        <p>Using <code>sprintf</code>:</p>

                                    </div>

                                    <p><code>sprintf</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $hex = sprintf(&quot;%X&quot;, 3735928559); # upper case A-F
        $hex = sprintf(&quot;%x&quot;, 3735928559); # lower case a-f</code></pre>

                                    <div class="original">

                                        <p>Using <code>unpack</code>:</p>

                                    </div>

                                    <p><code>unpack</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $hex = unpack(&quot;H*&quot;, pack(&quot;N&quot;, 3735928559));</code></pre>

                                    <div class="original">

                                        <p>Using <code>Bit::Vector</code>:</p>

                                    </div>

                                    <p><code>Bit::Vector</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        use Bit::Vector;
        $vec = Bit::Vector-&gt;new_Dec(32, -559038737);
        $hex = $vec-&gt;to_Hex();</code></pre>

                                    <div class="original">

                                        <p>And <code>Bit::Vector</code> supports odd bit counts:</p>

                                    </div>

                                    <p>そして <code>Bit::Vector</code> は半端なビット数にも対応しています:</p>

                                    <pre class="prettyprint lang-perl"><code>        use Bit::Vector;
        $vec = Bit::Vector-&gt;new_Dec(33, 3735928559);
        $vec-&gt;Resize(32); # suppress leading 0 if unwanted
        $hex = $vec-&gt;to_Hex();</code></pre>

                                </dd>
                                <dt>How do I convert from octal to decimal</dt>
                                <dd>

                                    <p>(8 進数を 10 進数に変換するには?)</p>

                                    <div class="original">

                                        <p>Using Perl&#39;s built in conversion of numbers with leading zeros:</p>

                                    </div>

                                    <p>先頭に 0 を付けることによる Perl 組み込みの変換を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $dec = 033653337357; # note the leading 0!</code></pre>

                                    <div class="original">

                                        <p>Using the <code>oct</code> function:</p>

                                    </div>

                                    <p><code>oct</code> function 関数を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $dec = oct(&quot;33653337357&quot;);</code></pre>

                                    <div class="original">

                                        <p>Using <code>Bit::Vector</code>:</p>

                                    </div>

                                    <p><code>Bit::Vector</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        use Bit::Vector;
        $vec = Bit::Vector-&gt;new(32);
        $vec-&gt;Chunk_List_Store(3, split(//, reverse &quot;33653337357&quot;));
        $dec = $vec-&gt;to_Dec();</code></pre>

                                </dd>
                                <dt>How do I convert from decimal to octal</dt>
                                <dd>

                                    <p>(10 進数を 8 進数に変換するには?)</p>

                                    <div class="original">

                                        <p>Using <code>sprintf</code>:</p>

                                    </div>

                                    <p><code>sprintf</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $oct = sprintf(&quot;%o&quot;, 3735928559);</code></pre>

                                    <div class="original">

                                        <p>Using <code>Bit::Vector</code>:</p>

                                    </div>

                                    <p><code>Bit::Vector</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        use Bit::Vector;
        $vec = Bit::Vector-&gt;new_Dec(32, -559038737);
        $oct = reverse join(&#39;&#39;, $vec-&gt;Chunk_List_Read(3));</code></pre>

                                </dd>
                                <dt>How do I convert from binary to decimal</dt>
                                <dd>

                                    <p>(2 進数から 10 進数に変換するには?)</p>

                                    <div class="original">

                                        <p>Perl 5.6 lets you write binary numbers directly with the <code>0b</code> notation:</p>

                                    </div>

                                    <p>Perl 5.6 から、<code>0b</code> 表記を使って直接 2 進数を書くことができます:</p>

                                    <pre class="prettyprint lang-perl"><code>        $number = 0b10110110;</code></pre>

                                    <div class="original">

                                        <p>Using <code>oct</code>:</p>

                                    </div>

                                    <p><code>oct</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        my $input = &quot;10110110&quot;;
        $decimal = oct( &quot;0b$input&quot; );</code></pre>

                                    <div class="original">

                                        <p>Using <code>pack</code> and <code>ord</code>:</p>

                                    </div>

                                    <p><code>pack</code> と <code>ord</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $decimal = ord(pack(&#39;B8&#39;, &#39;10110110&#39;));</code></pre>

                                    <div class="original">

                                        <p>Using <code>pack</code> and <code>unpack</code> for larger strings:</p>

                                    </div>

                                    <p>より大きな文字列に対しては、<code>pack</code> と <code>unpack</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $int = unpack(&quot;N&quot;, pack(&quot;B32&quot;,
        substr(&quot;0&quot; x 32 . &quot;11110101011011011111011101111&quot;, -32)));
        $dec = sprintf(&quot;%d&quot;, $int);

        # substr() is used to left pad a 32 character string with zeros.</code></pre>

                                    <div class="original">

                                        <p>Using <code>Bit::Vector</code>:</p>

                                    </div>

                                    <p><code>Bit::Vector</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $vec = Bit::Vector-&gt;new_Bin(32, &quot;11011110101011011011111011101111&quot;);
        $dec = $vec-&gt;to_Dec();</code></pre>

                                </dd>
                                <dt>How do I convert from decimal to binary</dt>
                                <dd>

                                    <div class="original">

                                        <p>Using <code>sprintf</code> (perl 5.6+):</p>

                                    </div>

                                    <p><code>sprintf</code> を使って(perl 5.6 以降):</p>

                                    <pre class="prettyprint lang-perl"><code>        $bin = sprintf(&quot;%b&quot;, 3735928559);</code></pre>

                                    <div class="original">

                                        <p>Using <code>unpack</code>:</p>

                                    </div>

                                    <p><code>unpack</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        $bin = unpack(&quot;B*&quot;, pack(&quot;N&quot;, 3735928559));</code></pre>

                                    <div class="original">

                                        <p>Using <code>Bit::Vector</code>:</p>

                                    </div>

                                    <p><code>Bit::Vector</code> を使って:</p>

                                    <pre class="prettyprint lang-perl"><code>        use Bit::Vector;
        $vec = Bit::Vector-&gt;new_Dec(32, -559038737);
        $bin = $vec-&gt;to_Bin();</code></pre>

                                    <div class="original">

                                        <p>The remaining transformations (e.g. hex -&gt; oct, bin -&gt; hex, etc.) are left as an exercise to the inclined reader.</p>

                                    </div>

                                    <p>残りの変換 (16 進 -&gt; 8 進、2 進 -&gt; 16 進、など) は読者への宿題として 残しておきます。</p>

                                </dd>
                            </dl>

                            <h2 id="Why32doesnt32work32the32way32I32want32it32to63">なぜ & は私の思った通りに動作しないのでしょうか?<a href="#Why32doesnt32work32the32way32I32want32it32to63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>The behavior of binary arithmetic operators depends on whether they&#39;re used on numbers or strings. The operators treat a string as a series of bits and work with that (the string <code>&quot;3&quot;</code> is the bit pattern <code>00110011</code>). The operators work with the binary form of a number (the number <code>3</code> is treated as the bit pattern <code>00000011</code>).</p>

                            </div>

                            <p>バイナリ算術演算子の振る舞いはそれが数値に対して使われているのか 文字列に対して使われているかということに依存しています。 その演算子は文字列をビットの並びとして扱います(<code>&quot;3&quot;</code> という文字列は <code>00110011</code> というビットパターンとなります)。 この演算子はバイナリ形式に対して働きます (<code>3</code> という数値は <code>00000011</code> というビットパターンとして扱われます)。</p>

                            <div class="original">

                                <p>So, saying <code>11 &amp; 3</code> performs the &quot;and&quot; operation on numbers (yielding <code>3</code>). Saying <code>&quot;11&quot; &amp; &quot;3&quot;</code> performs the &quot;and&quot; operation on strings (yielding <code>&quot;1&quot;</code>).</p>

                            </div>

                            <p>ですから、<code>11 &amp; 3</code> は数値に対する &quot;and&quot; として働きます(結果は <code>3</code> です)。 <code>&quot;11&quot; &amp; &quot;3&quot;</code>は文字列に対する &quot;and&quot; として働きます(結果は <code>&quot;1&quot;</code> です)。</p>

                            <div class="original">

                                <p>Most problems with <code>&amp;</code> and <code>|</code> arise because the programmer thinks they have a number but really it&#39;s a string. The rest arise because the programmer says:</p>

                            </div>

                            <p>ありがちな問題は <code>&amp;</code> と <code>|</code> を使ったときに、プログラマは オペランドが数値と考えているのに実際は文字列であるようなときに 起こります。 例を挙げましょう:</p>

                            <pre class="prettyprint lang-perl"><code>        if (&quot;\020\020&quot; &amp; &quot;\101\101&quot;) {
                # ...
                }</code></pre>

                            <div class="original">

                                <p>but a string consisting of two null bytes (the result of <code>&quot;\020\020&quot; &amp; &quot;\101\101&quot;</code>) is not a false value in Perl. You need:</p>

                            </div>

                            <p>この場合の結果は二つのナルバイトを含む文字列となります (<code>&quot;\020\020&quot;</code> の結果です)が、これは Perl における偽の値では ありません。 以下のようにする必要があります:</p>

                            <pre class="prettyprint lang-perl"><code>        if ( (&quot;\020\020&quot; &amp; &quot;\101\101&quot;) !~ /[^\000]/) {
                # ...
                }</code></pre>

                            <h2 id="How32do32I32multiply32matrices63">行列の積を計算するには?<a href="#How32do32I32multiply32matrices63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Use the Math::Matrix or Math::MatrixReal modules (available from CPAN) or the PDL extension (also available from CPAN).</p>

                            </div>

                            <p>Math::Matrix モジュールか、Math::MatrixReal モジュール(CPAN で入手できます)か PDL エクステンション(これも CPAN で入手できます)を使います。</p>

                            <h2 id="How32do32I32perform32an32operation32on32a32series32of32integers63">整数値の並びに対してある操作を実行するには?<a href="#How32do32I32perform32an32operation32on32a32series32of32integers63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>To call a function on each element in an array, and collect the results, use:</p>

                            </div>

                            <p>配列の各要素に対して関数を呼び出して、結果を集めるにはこうします:</p>

                            <pre class="prettyprint lang-perl"><code>        @results = map { my_func($_) } @array;</code></pre>

                            <div class="original">

                                <p>For example:</p>

                            </div>

                            <p>例えば:</p>

                            <pre class="prettyprint lang-perl"><code>        @triple = map { 3 * $_ } @single;</code></pre>

                            <div class="original">

                                <p>To call a function on each element of an array, but ignore the results:</p>

                            </div>

                            <p>配列の各要素に対して関数を呼び出すけれども、結果を無視するという 場合にはこうします:</p>

                            <pre class="prettyprint lang-perl"><code>        foreach $iterator (@array) {
                some_func($iterator);
                }</code></pre>

                            <div class="original">

                                <p>To call a function on each integer in a (small) range, you <b>can</b> use:</p>

                            </div>

                            <p>ある(小さな)範囲にある整数に対して関数を呼び出すには、こうも <b>できます</b>:</p>

                            <pre class="prettyprint lang-perl"><code>        @results = map { some_func($_) } (5 .. 25);</code></pre>

                            <div class="original">

                                <p>but you should be aware that the <code>..</code> operator creates an array of all integers in the range. This can take a lot of memory for large ranges. Instead use:</p>

                            </div>

                            <p>ただし、<code>..</code> 演算子がその範囲にあるすべての整数の配列を生成するということに 注意すべきでしょう。 これによって大きな範囲を使った場合に大量のメモリを消費することになります。 代わりにこうします:</p>

                            <pre class="prettyprint lang-perl"><code>        @results = ();
        for ($i=5; $i &lt; 500_005; $i++) {
                push(@results, some_func($i));
                }</code></pre>

                            <div class="original">

                                <p>This situation has been fixed in Perl5.005. Use of <code>..</code> in a <code>for</code> loop will iterate over the range, without creating the entire range.</p>

                            </div>

                            <p>この状況は Perl5.005 で修正されました。 <code>for</code> ループで <code>..</code> を使うことで、 範囲全体を生成することなく特定の範囲の繰り返しを行えます。</p>

                            <pre class="prettyprint lang-perl"><code>        for my $i (5 .. 500_005) {
                push(@results, some_func($i));
                }</code></pre>

                            <div class="original">

                                <p>will not create a list of 500,000 integers.</p>

                            </div>

                            <p>このようにしても 500,000 個の整数のリストが生成されたりはしません。</p>

                            <h2 id="How32can32I32output32Roman32numerals63">ローマ数字を出力するには?<a href="#How32can32I32output32Roman32numerals63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Get the http://www.cpan.org/modules/by-module/Roman module.</p>

                            </div>

                            <p>http://www.cpan.org/modules/by-module/Roman モジュールを入手しましょう。</p>

                            <h2 id="Why32arent32my32random32numbers32random63">なぜ私の乱数はランダムでないの?<a href="#Why32arent32my32random32numbers32random63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>If you&#39;re using a version of Perl before 5.004, you must call <code>srand</code> once at the start of your program to seed the random number generator.</p>

                            </div>

                            <p>5.004 より前のバージョンの Perl を使っているなら、<code>srand</code> を プログラムの開始時点で一度呼び出してやって、乱数生成器の種を セットしてやらなければなりません。</p>

                            <pre class="prettyprint lang-perl"><code>         BEGIN { srand() if $] &lt; 5.004 }</code></pre>

                            <div class="original">

                                <p>5.004 and later automatically call <code>srand</code> at the beginning. Don&#39;t call <code>srand</code> more than once--you make your numbers less random, rather than more.</p>

                            </div>

                            <p>5.004 以降のものでは開始時点で自動的に <code>srand</code> を呼び出します。 二度以上 <code>srand</code> を呼び出してはいけません。 乱数の質を落としてしまいます。</p>

                            <div class="original">

                                <p>Computers are good at being predictable and bad at being random (despite appearances caused by bugs in your programs :-). see the <i>random</i> article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz , courtesy of Tom Phoenix, talks more about this. John von Neumann said, &quot;Anyone who attempts to generate random numbers by deterministic means is, of course, living in a state of sin.&quot;</p>

                            </div>

                            <p>コンピュータは予測できる物事に関しては役に立ちますが、ランダムな ことに対してはそうではありません(それはあなたのプログラム自身のバグによって 引き起こされることですが:-) Tom Phoenix がこの問題について語っている、 http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz の &quot;Far More Than You Ever Wanted To Know&quot; の中の <i>random</i> という記事を 参照してください。 ジョン・フォン・ノイマン曰く、「決定論的手段によって 乱数を作ろうと試みる全ての人はもちろん罪深きものである。」</p>

                            <div class="original">

                                <p>If you want numbers that are more random than <code>rand</code> with <code>srand</code> provides, you should also check out the <code>Math::TrulyRandom</code> module from CPAN. It uses the imperfections in your system&#39;s timer to generate random numbers, but this takes quite a while. If you want a better pseudorandom generator than comes with your operating system, look at &quot;Numerical Recipes in C&quot; at http://www.nr.com/ .</p>

                            </div>

                            <p><code>rand</code> と <code>srand</code> が提供するものよりもよりランダムな数値が必要なら、 CPAN にある <code>Math::TrulyRandom</code> モジュールも チェックしてみると良いでしょう。 これはあなたの使っているシステムのタイマーを乱数を生成するのに 使っていて不完全な面もありますが、十分なものです。 あなたの使うオペレーティングシステムで使えるものよりも もっと良質な擬似乱数を必要としているのなら、 http://www.nr.com にある ``Numerical Recipes in C&#39;&#39; を見るとよいでしょう。</p>

                            <h2 id="How32do32I32get32a32random32number32between32X32and32Y63">X と Y の間の乱数を得るには?<a href="#How32do32I32get32a32random32number32between32X32and32Y63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>To get a random number between two values, you can use the <code>rand()</code> built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</p>

                            </div>

                            <p>二つの値の間の乱数を得るためには、まず 0 と 1 との間の乱数を得るために <code>rand()</code> 組み込み関数を使います。 それから、これを必要な範囲にシフトします。</p>

                            <div class="original">

                                <p><code>rand($x)</code> returns a number such that <code>0 &lt;= rand($x) &lt; $x</code>. Thus what you want to have perl figure out is a random number in the range from 0 to the difference between your <i>X</i> and <i>Y</i>.</p>

                            </div>

                            <p><code>rand($x)</code> は <code>0 &lt;= rand($x) &lt; $x</code> という値を返します。 従って、perl に作ってほしいものは、0 から、必要な <i>X</i> と <i>Y</i> との差 までの範囲の乱数です。</p>

                            <div class="original">

                                <p>That is, to get a number between 10 and 15, inclusive, you want a random number between 0 and 5 that you can then add to 10.</p>

                            </div>

                            <p>つまり、10 から 15 の範囲の値(両端を含む) を得るためには、 0 から 5 の範囲の乱数を求めて、それに 10 を加えます。</p>

                            <pre class="prettyprint lang-perl"><code>        my $number = 10 + int rand( 15-10+1 ); # ( 10,11,12,13,14, or 15 )</code></pre>

                            <div class="original">

                                <p>Hence you derive the following simple function to abstract that. It selects a random integer between the two given integers (inclusive), For example: <code>random_int_between(50,120)</code>.</p>

                            </div>

                            <p>従って、これを抽象化するために以下のサンプル関数を導き出します。 これは与えられた二つの整数を含む範囲のランダムな整数を選択します。 例えば: <code>random_int_between(50,120)</code></p>

                            <pre class="prettyprint lang-perl"><code>        sub random_int_between {
                my($min, $max) = @_;
                # Assumes that the two arguments are integers themselves!
                return $min if $min == $max;
                ($min, $max) = ($max, $min)  if  $min &gt; $max;
                return $min + int rand(1 + $max - $min);
                }</code></pre>

                            <h1 id="Data:32Dates">データ:日付<a href="#Data:32Dates" class="toc_link">&#182;</a></h1>

                            <p></p>

                            <h2 id="How32do32I32find32the32day32or32week32of32the32year63">その年の何日目であるかを知るには?<a href="#How32do32I32find32the32day32or32week32of32the32year63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>The localtime function returns the day of the year. Without an argument localtime uses the current time.</p>

                            </div>

                            <p>localtime 関数はその年の何日目であるかを返します。 引数なしの localtime は現在時刻を使います。</p>

                            <pre class="prettyprint lang-perl"><code>        $day_of_year = (localtime)[7];</code></pre>

                            <div class="original">

                                <p>The <code>POSIX</code> module can also format a date as the day of the year or week of the year.</p>

                            </div>

                            <p><code>POSIX</code> モジュールも日付をその年の何日目か、または何週目かに整形します。</p>

                            <pre class="prettyprint lang-perl"><code>        use POSIX qw/strftime/;
        my $day_of_year  = strftime &quot;%j&quot;, localtime;
        my $week_of_year = strftime &quot;%W&quot;, localtime;</code></pre>

                            <div class="original">

                                <p>To get the day of year for any date, use <code>POSIX</code>&#39;s <code>mktime</code> to get a time in epoch seconds for the argument to localtime.</p>

                            </div>

                            <p>任意の日付に対してその年の何日目かを得るには、localtime の引数から 紀元からの秒数を求めるために、<code>POSIX</code> の <code>mktime</code> を使います。</p>

                            <pre class="prettyprint lang-perl"><code>        use POSIX qw/mktime strftime/;
        my $week_of_year = strftime &quot;%W&quot;,
                localtime( mktime( 0, 0, 0, 18, 11, 87 ) );</code></pre>

                            <div class="original">

                                <p>The <code>Date::Calc</code> module provides two functions to calculate these.</p>

                            </div>

                            <p><code>Date::Calc</code> モジュールはこれらを計算する二つの関数を提供します。</p>

                            <pre class="prettyprint lang-perl"><code>        use Date::Calc;
        my $day_of_year  = Day_of_Year(  1987, 12, 18 );
        my $week_of_year = Week_of_Year( 1987, 12, 18 );</code></pre>

                            <h2 id="How32do32I32find32the32current32century32or32millennium63">現在の世紀や千年紀を知るには?<a href="#How32do32I32find32the32current32century32or32millennium63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Use the following simple functions:</p>

                            </div>

                            <p>以下の単純な関数を使ってください:</p>

                            <pre class="prettyprint lang-perl"><code>        sub get_century    {
                return int((((localtime(shift || time))[5] + 1999))/100);
                }

        sub get_millennium {
                return 1+int((((localtime(shift || time))[5] + 1899))/1000);
                }</code></pre>

                            <div class="original">

                                <p>On some systems, the <code>POSIX</code> module&#39;s <code>strftime()</code> function has been extended in a non-standard way to use a <code>%C</code> format, which they sometimes claim is the &quot;century&quot;. It isn&#39;t, because on most such systems, this is only the first two digits of the four-digit year, and thus cannot be used to reliably determine the current century or millennium.</p>

                            </div>

                            <p>システムによっては、<code>POSIX</code> モジュールの <code>strftime()</code> 関数が 非標準の方法で <code>%C</code> フォーマット(&quot;century&quot;だと主張されることがあります)を 使うように拡張されているかもしれません。 これは世紀ではありません。 なぜならこのようなシステムのほとんどでは、 これは 4 桁の年の上位 2 桁を示しているだけなので、 現在の世紀や千年紀を決定する信頼できる方法ではありません。</p>

                            <h2 id="How32can32I32compare32two32dates32and32find32the32difference63">二つの日付文字列を比較するには?<a href="#How32can32I32compare32two32dates32and32find32the32difference63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>You could just store all your dates as a number and then subtract. Life isn&#39;t always that simple though. If you want to work with formatted dates, the <code>Date::Manip</code>, <code>Date::Calc</code>, or <code>DateTime</code> modules can help you.</p>

                            </div>

                            <p>日付を単に数値として保管して、それから引き算することもできます。 しかし、人生はいつもこんな風に単純とは限りません。 フォーマットされた日付に対して作業したい場合は、 <code>Date::Manip</code>, <code>Date::Calc</code>, <code>DateTime</code> といったモジュールが 助けになるかもしれません。</p>

                            <h2 id="How32can32I32take32a32string32and32turn32it32into32epoch32seconds63">文字列を受け取って、それを紀元からの経過秒数に変換するには?<a href="#How32can32I32take32a32string32and32turn32it32into32epoch32seconds63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>If it&#39;s a regular enough string that it always has the same format, you can split it up and pass the parts to <code>timelocal</code> in the standard <code>Time::Local</code> module. Otherwise, you should look into the <code>Date::Calc</code> and <code>Date::Manip</code> modules from CPAN.</p>

                            </div>

                            <p>もしそれが常に同じ書式である十分に標準的な文字列であれば、それを分割して、 その部分部分を標準の Time::Local モジュールの <code>timelocal</code> に渡せます。 さもなければ、CPAN にある <code>Date::Calc</code> モジュールと <code>Date::Manip</code> モジュールを見るべきでしょう。</p>

                            <h2 id="How32can32I32find32the32Julian32Day63">ユリウス日を求めるには?<a href="#How32can32I32find32the32Julian32Day63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy and Dave Cross)</p>

                            </div>

                            <p>(brian d foy と Dave Cross によって寄贈されました)</p>

                            <div class="original">

                                <p>You can use the <code>Time::JulianDay</code> module available on CPAN. Ensure that you really want to find a Julian day, though, as many people have different ideas about Julian days. See http://www.hermetic.ch/cal_stud/jdn.htm for instance.</p>

                            </div>

                            <p>CPAN にある <code>Time::JulianDay</code> モジュールが使えます。 しかし、本当にユリウス日がほしいのか確認してください; 多くの人々がユリウス日に関して異なる考え方を持っています。 例としては、http://www.hermetic.ch/cal_stud/jdn.htm を参照してください。</p>

                            <div class="original">

                                <p>You can also try the <code>DateTime</code> module, which can convert a date/time to a Julian Day.</p>

                            </div>

                            <p>日付・時刻をユリウス日に変換できる、<code>DateTime</code> モジュールを試すことも できます。</p>

                            <pre class="prettyprint lang-perl"><code>        $ perl -MDateTime -le&#39;print DateTime-&gt;today-&gt;jd&#39;
        2453401.5</code></pre>

                            <div class="original">

                                <p>Or the modified Julian Day</p>

                            </div>

                            <p>あるいは準ユリウス日にも変換できます:</p>

                            <pre class="prettyprint lang-perl"><code>        $ perl -MDateTime -le&#39;print DateTime-&gt;today-&gt;mjd&#39;
        53401</code></pre>

                            <div class="original">

                                <p>Or even the day of the year (which is what some people think of as a Julian day)</p>

                            </div>

                            <p>あるいは年の何日目か(これがユリウス日だと考える人もいます)にも変換できます:</p>

                            <pre class="prettyprint lang-perl"><code>        $ perl -MDateTime -le&#39;print DateTime-&gt;today-&gt;doy&#39;
        31</code></pre>

                            <h2 id="How32do32I32find32yesterdays32date63">昨日の日付を得るには?<a href="#How32do32I32find32yesterdays32date63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>Use one of the Date modules. The <code>DateTime</code> module makes it simple, and give you the same time of day, only the day before.</p>

                            </div>

                            <p>Date モジュールの一つを使いましょう。 <code>DateTime</code> モジュールは単純で、前日の同じ時刻を返します。</p>

                            <pre class="prettyprint lang-perl"><code>        use DateTime;

        my $yesterday = DateTime-&gt;now-&gt;subtract( days =&gt; 1 );

        print &quot;Yesterday was $yesterday\n&quot;;</code></pre>

                            <div class="original">

                                <p>You can also use the <code>Date::Calc</code> module using its <code>Today_and_Now</code> function.</p>

                            </div>

                            <p><code>Date::Calc</code> モジュールの <code>Today_and_Now</code> 関数を使うこともできます。</p>

                            <pre class="prettyprint lang-perl"><code>        use Date::Calc qw( Today_and_Now Add_Delta_DHMS );

        my @date_time = Add_Delta_DHMS( Today_and_Now(), -1, 0, 0, 0 );

        print &quot;@date_time\n&quot;;</code></pre>

                            <div class="original">

                                <p>Most people try to use the time rather than the calendar to figure out dates, but that assumes that days are twenty-four hours each. For most people, there are two days a year when they aren&#39;t: the switch to and from summer time throws this off. Let the modules do the work.</p>

                            </div>

                            <p>ほとんどの人は日付を計算するのにカレンダーではなく時刻を使おうとしますが、 これは 1 日が 24 時間であることを仮定しています。 ほとんどの人々にとって、そうではない日が 2 日あります: 夏時間が始まる日と終わる日はこれを狂わせます。 この作業はモジュールにさせましょう。</p>

                            <div class="original">

                                <p>If you absolutely must do it yourself (or can&#39;t use one of the modules), here&#39;s a solution using <code>Time::Local</code>, which comes with Perl:</p>

                            </div>

                            <p>もし完全に自分でしなければならない (あるいはこれらのモジュールが 使えない) 場合は、以下が Perl と共に配布されている <code>Time::Local</code> を 使った解法です:</p>

                            <pre class="prettyprint lang-perl"><code>        # contributed by Gunnar Hjalmarsson
         use Time::Local;
         my $today = timelocal 0, 0, 12, ( localtime )[3..5];
         my ($d, $m, $y) = ( localtime $today-86400 )[3..5];
         printf &quot;Yesterday: %d-%02d-%02d\n&quot;, $y+1900, $m+1, $d;</code></pre>

                            <div class="original">

                                <p>In this case, you measure the day starting at noon, and subtract 24 hours. Even if the length of the calendar day is 23 or 25 hours, you&#39;ll still end up on the previous calendar day, although not at noon. Since you don&#39;t care about the time, the one hour difference doesn&#39;t matter and you end up with the previous date.</p>

                            </div>

                            <p>この場合、正午から始まる日数を計算して、24 時間を引いています。 たとえばカレンダー日の長さが 23 時間や 25 時間でも、結局 カレンダーの前日を得られますが、この場合正午ではありません。 時刻については気にしないので、1 時間のずれは関係なく、最終的に 前日を得られます。</p>

                            <h2 id="Does32Perl32have32a32Year32200032problem63Is32Perl32Y2K32compliant63">Perl には 2000 年問題があるのですか? Perl は 2000 年対応ですか?<a href="#Does32Perl32have32a32Year32200032problem63Is32Perl32Y2K32compliant63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Short answer: No, Perl does not have a Year 2000 problem. Yes, Perl is Y2K compliant (whatever that means). The programmers you&#39;ve hired to use it, however, probably are not.</p>

                            </div>

                            <p>短い答: いいえ、Perl には 2000 年問題はありません。 はい、Perl は(どのような意味でも) 2000 年対応です。 ただし、あなたの雇っているプログラマがそうでないように 使っているなら 2000 年問題はあります。</p>

                            <div class="original">

                                <p>Long answer: The question belies a true understanding of the issue. Perl is just as Y2K compliant as your pencil--no more, and no less. Can you use your pencil to write a non-Y2K-compliant memo? Of course you can. Is that the pencil&#39;s fault? Of course it isn&#39;t.</p>

                            </div>

                            <p>長い答: この質問は物事の理解を誤っています。 Perl はあなたの鉛筆と同じぐらいに Y2K 対応です。 それ以上でもそれ以下でもありません。 あなたの鉛筆を使って Y2K 対応でないメモを書けますか? もちろん書けます。 それは鉛筆のせいですか? もちろん違います。</p>

                            <div class="original">

                                <p>The date and time functions supplied with Perl (gmtime and localtime) supply adequate information to determine the year well beyond 2000 (2038 is when trouble strikes for 32-bit machines). The year returned by these functions when used in a list context is the year minus 1900. For years between 1910 and 1999 this <i>happens</i> to be a 2-digit decimal number. To avoid the year 2000 problem simply do not treat the year as a 2-digit number. It isn&#39;t.</p>

                            </div>

                            <p>Perl に組み込みの日付・時刻関数(gmtimeとlocaltime)は 2000 年を越えた年も区別するために必要な情報を提供しています (32 ビットマシンをトラブルが直撃するのは2038年です)。 これらの関数がリストコンテキストで使われたときに返す年数は 実際の年から 1900 を引いた値です。1910 年から 1999 年は このやり方では <b>たまたま</b> 二桁の数値となります。 2000 年問題を避けるには、年を二桁で扱わないようにします。</p>

                            <div class="original">

                                <p>When gmtime() and localtime() are used in scalar context they return a timestamp string that contains a fully-expanded year. For example, <code>$timestamp = gmtime(1005613200)</code> sets $timestamp to &quot;Tue Nov 13 01:00:00 2001&quot;. There&#39;s no year 2000 problem here.</p>

                            </div>

                            <p>gmtime() や localtime() は、スカラコンテキストで呼び出された場合には 完全な年を含んでいるタイムスタンプ文字列を返します。 たとえば、<code>$timestamp = gmtime(1005613200)</code> は $timestamp に &quot;Tue Nov 13 01:00:00 2001&quot; をセットします。 ここには 2000 年問題はありません。</p>

                            <div class="original">

                                <p>That doesn&#39;t mean that Perl can&#39;t be used to create non-Y2K compliant programs. It can. But so can your pencil. It&#39;s the fault of the user, not the language. At the risk of inflaming the NRA: &quot;Perl doesn&#39;t break Y2K, people do.&quot; See http://www.perl.org/about/y2k.html for a longer exposition.</p>

                            </div>

                            <p>このことは、Perl で 2000 年問題を起こすようなプログラムを作るのに 使えないということではありません。あなたの使う鉛筆も そうであるように。つまり、言語にまつわるミスではなく、使う人の 間違いであるということです。 NRA を刺激するかもしれませんが、 「Perl は 2000 年問題を打ち破らない。人が打ち破るのだ。」ということです。 詳しい説明は http://www.perl.org/about/y2k.html を参照してください。</p>

                            <h1 id="Data:32Strings">データ: 文字列<a href="#Data:32Strings" class="toc_link">&#182;</a></h1>

                            <p></p>

                            <h2 id="How32do32I32validate32input63">入力を検査するには?<a href="#How32do32I32validate32input63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as <code>Regexp::Common</code>.</p>

                            </div>

                            <p>値があなたの予測している、または受け入れたいものであることを保証するには 多くの方法があります。 perlfaq でカバーする特定の例の他に、名前に &quot;Assert&quot; や &quot;Validate&quot; がある モジュールや、<code>Regexp::Common</code> のようなその他のモジュールを 見ることもできます。</p>

                            <div class="original">

                                <p>Some modules have validation for particular types of input, such as <code>Business::ISBN</code>, <code>Business::CreditCard</code>, <code>Email::Valid</code>, and <code>Data::Validate::IP</code>.</p>

                            </div>

                            <p><code>Business::ISBN</code>, <code>Business::CreditCard</code>, <code>Email::Valid</code>, <code>Data::Validate::IP</code> のように、特定の種類の入力を検査するための モジュールもあります。</p>

                            <h2 id="How32do32I32unescape32a32string63">文字列のアンエスケープ (unescape)をするには?<a href="#How32do32I32unescape32a32string63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in <a href="/pod/perlfaq9">perlfaq9</a>. Shell escapes with the backslash (<code>\</code>) character are removed with</p>

                            </div>

                            <p>それはあなたのいう「エスケープ」がなんであるかによります。 URL のエスケープは <a href="/pod/perlfaq9">perlfaq9</a> で扱っています。 バックスラッシュによるシェルエスケープは以下のようにして取り除きます:</p>

                            <pre class="prettyprint lang-perl"><code>        s/\\(.)/$1/g;</code></pre>

                            <div class="original">

                                <p>This won&#39;t expand <code>&quot;\n&quot;</code> or <code>&quot;\t&quot;</code> or any other special escapes.</p>

                            </div>

                            <p>これは <code>\n</code> だとか <code>\t</code>、あるいはその他の特殊なエスケープを展開しません。</p>

                            <h2 id="How32do32I32remove32consecutive32pairs32of32characters63">キャラクタの連続した組を取り除くには?<a href="#How32do32I32remove32consecutive32pairs32of32characters63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>You can use the substitution operator to find pairs of characters (or runs of characters) and replace them with a single instance. In this substitution, we find a character in <code>(.)</code>. The memory parentheses store the matched character in the back-reference <code>\1</code> and we use that to require that the same thing immediately follow it. We replace that part of the string with the character in <code>$1</code>.</p>

                            </div>

                            <p>文字の組(または文字の並び)を探して、それを一つの実体に置き換えるには 置換演算子が使えます。 この置換で、<code>(.)</code> で一文字が見付かります。 記憶用のかっこはマッチングした文字を後方参照 <code>\1</code> に保管し、 同じ文字を直後に要求するために使います。 文字列の一部を <code>$1</code> にある文字で置き換えます。</p>

                            <pre class="prettyprint lang-perl"><code>        s/(.)\1/$1/g;</code></pre>

                            <div class="original">

                                <p>We can also use the transliteration operator, <code>tr///</code>. In this example, the search list side of our <code>tr///</code> contains nothing, but the <code>c</code> option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won&#39;t do any replacements (or more exactly, replace the character with itself). However, the <code>s</code> option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</p>

                            </div>

                            <p>文字変換演算子 <code>tr///</code> も使えます。 この例では、<code>tr///</code> の検索リスト側は何も入っていませんが、<code>c</code> オプションが ついているので全てが含まれます。 置き換えリスト側にも何も入っていないので、文字変換はほとんど何もしません (より厳密には、文字はその文字自身に置き換えられます)。 しかし、<code>s</code> オプションは文字列中の重複していて連続した文字を 1 文字に 短縮するので、次に同じ文字がある文字は表示されません:</p>

                            <pre class="prettyprint lang-perl"><code>        my $str = &#39;Haarlem&#39;;   # in the Netherlands
        $str =~ tr///cs;       # Now Harlem, like in New York</code></pre>

                            <h2 id="How32do32I32expand32function32calls32in32a32string63">文字列中にある関数呼び出しを展開するには?<a href="#How32do32I32expand32function32calls32in32a32string63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>This is documented in <a href="/pod/perlref">perlref</a>, and although it&#39;s not the easiest thing to read, it does work. In each of these examples, we call the function inside the braces used to dereference a reference. If we have more than one return value, we can construct and dereference an anonymous array. In this case, we call the function in list context.</p>

                            </div>

                            <p>これは <a href="/pod/perlref">perlref</a> に文書化されていて、もっとも読みやすいものでは ありませんが、動きます。 これらの例のそれぞれにおいて、大かっこの内側の関数はリファレンスを デリファレンスするために呼び出します。 もし複数の返り値がある場合、無名配列を構築して、デリファレンスします。 この場合、関数をリストコンテキストで呼び出します。</p>

                            <pre class="prettyprint lang-perl"><code>        print &quot;The time values are @{ [localtime] }.\n&quot;;</code></pre>

                            <div class="original">

                                <p>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need <code>scalar</code> to force the scalar context on the function:</p>

                            </div>

                            <p>スカラコンテキストで関数を呼び出したい場合、もう少し作業が必要です。 実際に置きたいどんなコードでも中かっこの中に置けるので、 (それをどのようにするかはあなた次第で、中かっこのなかのコードを使えますが) 単にスカラリファレンスで終了する必要があります。 かっこはリストコンテキストを作成するので、関数内でスカラコンテキストを 強制するために <code>scalar</code> が必要であることに注意してください:</p>

                            <pre class="prettyprint lang-perl"><code>        print &quot;The time is ${\(scalar localtime)}.\n&quot;

        print &quot;The time is ${ my $x = localtime; \$x }.\n&quot;;</code></pre>

                            <div class="original">

                                <p>If your function already returns a reference, you don&#39;t need to create the reference yourself.</p>

                            </div>

                            <p>関数がすでにリファレンスを返す場合、自分でリファレンスを作る必要は ありません。</p>

                            <pre class="prettyprint lang-perl"><code>        sub timestamp { my $t = localtime; \$t }

        print &quot;The time is ${ timestamp() }.\n&quot;;</code></pre>

                            <div class="original">

                                <p>The <code>Interpolation</code> module can also do a lot of magic for you. You can specify a variable name, in this case <code>E</code>, to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</p>

                            </div>

                            <p><code>Interpolation</code> モジュールもまたあなたのために多くの魔法を使います。 展開を行う tie されたハッシュを設定するための変数名(この場合は <code>E</code>)を 指定できます。 同じようにこれを行うその他のいくつかのメソッドを持っています。</p>

                            <pre class="prettyprint lang-perl"><code>        use Interpolation E =&gt; &#39;eval&#39;;
        print &quot;The time values are $E{localtime()}.\n&quot;;</code></pre>

                            <div class="original">

                                <p>In most cases, it is probably easier to simply use string concatenation, which also forces scalar context.</p>

                            </div>

                            <p>ほとんどの場合、文字列連結を使ってスカラコンテキストに強制するほうが おそらくより簡単です。</p>

                            <pre class="prettyprint lang-perl"><code>        print &quot;The time is &quot; . localtime() . &quot;.\n&quot;;</code></pre>

                            <h2 id="How32do32I32find32matching47nesting32anything63">何かがマッチしている/ネストしているということを検出するには?<a href="#How32do32I32find32matching47nesting32anything63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>This isn&#39;t something that can be done in one regular expression, no matter how complicated. To find something between two single characters, a pattern like <code>/x([^x]*)x/</code> will get the intervening bits in $1. For multiple ones, then something more like <code>/alpha(.*?)omega/</code> would be needed. But none of these deals with nested patterns. For balanced expressions using <code>(</code>, <code>{</code>, <code>[</code> or <code>&lt;</code> as delimiters, use the CPAN module Regexp::Common, or see <a href="/pod/perlre#40code32">&quot;(??{ code })&quot; in perlre</a>. For other cases, you&#39;ll have to write a parser.</p>

                            </div>

                            <p>これは一つの正規表現で解決できないほどの複雑な問題なのです。 単一のキャラクター二つに囲まれた何かを見つけだすには、 <code>/x([^x]*)x/</code> といったパターンを使えば $1 に検査の結果が得られるでしょう。 複数キャラクターに囲まれたものの場合は、 <code>/alpha(.*?)omega/</code> のようなパターンが必要となるでしょう。 しかし、ネストしたパターンを扱うようなものはありませんし、できません。 <code>(</code>, <code>{</code>, <code>[</code>, <code>&lt;</code> のいずれかのバランス表現をデリミタとして 使っている場合、CPAN にある Regexp::Common モジュールを使うか、 <a href="/pod/perlre#40code32">&quot;(??{ code })&quot; in perlre</a> を参照してください。 その他の場合では、パーサーを書く必要があります。</p>

                            <div class="original">

                                <p>If you are serious about writing a parser, there are a number of modules or oddities that will make your life a lot easier. There are the CPAN modules <code>Parse::RecDescent</code>, <code>Parse::Yapp</code>, and <code>Text::Balanced</code>; and the <code>byacc</code> program. Starting from perl 5.8 the <code>Text::Balanced</code> is part of the standard distribution.</p>

                            </div>

                            <p>もしまじめにパーザを作ろうと考えているのなら、 それを手助けしてくれるようなモジュールやその他のプログラムがあります。 CPAN には <code>Parse::RecDescent</code>, <code>Parse::Yapp</code>, <code>Text::Balanced</code> がありますし、<code>byacc</code> プログラムもあります。 perl 5.8 から、<code>Text::Balanced</code> は標準配布の一部になりました。</p>

                            <div class="original">

                                <p>One simple destructive, inside-out approach that you might try is to pull out the smallest nesting parts one at a time:</p>

                            </div>

                            <p>単純で破壊的な inside-out アプローチもあります。 これは以下のようにして一度に最小のネスト部分を取り出そうというものです。</p>

                            <pre class="prettyprint lang-perl"><code>        while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {
                # do something with $1
                }</code></pre>

                            <div class="original">

                                <p>A more complicated and sneaky approach is to make Perl&#39;s regular expression engine do it for you. This is courtesy Dean Inada, and rather has the nature of an Obfuscated Perl Contest entry, but it really does work:</p>

                            </div>

                            <p>より複雑で巧妙なやり方に Perl の正規表現エンジンを使うというものがあります。 これは Dean Inada によるもので Obfuscated Perl コンテストに エントリされるような代物ですが、正しく働きます:</p>

                            <div class="original">

<pre class="prettyprint lang-perl"><code>        # $_ contains the string to parse
        # BEGIN and END are the opening and closing markers for the
        # nested text.</code></pre>

                            </div>

                            <pre class="prettyprint lang-perl"><code>        # $_ には解析対象の文字列があります
        # BEGINとENDはネストしたテキストの開始と終了とを行います。

        @( = (&#39;(&#39;,&#39;&#39;);
        @) = (&#39;)&#39;,&#39;&#39;);
        ($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;
        @$ = (eval{/$re/},$@!~/unmatched/i);
        print join(&quot;\n&quot;,@$[0..$#$]) if( $$[-1] );</code></pre>

                            <h2 id="How32do32I32reverse32a32string63">文字列をひっくり返すには?<a href="#How32do32I32reverse32a32string63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Use <code>reverse()</code> in scalar context, as documented in <a href="/pod/perlfunc#reverse">&quot;reverse&quot; in perlfunc</a>.</p>

                            </div>

                            <p><a href="/pod/perlfunc#reverse">&quot;reverse&quot; in perlfunc</a> で説明されているように、スカラコンテキストで <code>reverse()</code> を使います。</p>

                            <pre class="prettyprint lang-perl"><code>        $reversed = reverse $string;</code></pre>

                            <h2 id="How32do32I32expand32tabs32in32a32string63">文字列中にあるタブを展開するには?<a href="#How32do32I32expand32tabs32in32a32string63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>You can do it yourself:</p>

                            </div>

                            <p>以下のようにしてできます:</p>

                            <pre class="prettyprint lang-perl"><code>        1 while $string =~ s/\t+/&#39; &#39; x (length($&amp;) * 8 - length($`) % 8)/e;</code></pre>

                            <div class="original">

                                <p>Or you can just use the <code>Text::Tabs</code> module (part of the standard Perl distribution).</p>

                            </div>

                            <p>あるいは、ただ単に <code>Text::Tabs</code> モジュール(標準 Perl 配布キットの一部です)を 使ってもできます。</p>

                            <pre class="prettyprint lang-perl"><code>        use Text::Tabs;
        @expanded_lines = expand(@lines_with_tabs);</code></pre>

                            <h2 id="How32do32I32reformat32a32paragraph63">段落を整形するには?<a href="#How32do32I32reformat32a32paragraph63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Use <code>Text::Wrap</code> (part of the standard Perl distribution):</p>

                            </div>

                            <p><code>Text::Wrap</code> (標準 Perl 配布キットの一部です)を使います。</p>

                            <pre class="prettyprint lang-perl"><code>        use Text::Wrap;
        print wrap(&quot;\t&quot;, &#39;  &#39;, @paragraphs);</code></pre>

                            <div class="original">

                                <p>The paragraphs you give to <code>Text::Wrap</code> should not contain embedded newlines. <code>Text::Wrap</code> doesn&#39;t justify the lines (flush-right).</p>

                            </div>

                            <p><code>Text::Wrap</code> に与える段落には埋め込みの改行があってはいけません。 <code>Text::Wrap</code> は行を均等割り付けしません(左寄せします)。</p>

                            <div class="original">

                                <p>Or use the CPAN module <code>Text::Autoformat</code>. Formatting files can be easily done by making a shell alias, like so:</p>

                            </div>

                            <p>または CPAN の <code>Text::Autoformat</code> モジュールを使ってください。 ファイルの整形は以下のようにシェルエイリアスを作ることによって 簡単に実現できます:</p>

                            <pre class="prettyprint lang-perl"><code>        alias fmt=&quot;perl -i -MText::Autoformat -n0777 \
                -e &#39;print autoformat $_, {all=&gt;1}&#39; $*&quot;</code></pre>

                            <div class="original">

                                <p>See the documentation for <code>Text::Autoformat</code> to appreciate its many capabilities.</p>

                            </div>

                            <p>その多くの能力を評価するために、<code>Text::Autoformat</code> の文書を 参照してください。</p>

                            <h2 id="How32can32I32access32or32change32N32characters32of32a32string63">文字列の最初の N 文字にアクセスしたり、それを変更するには?<a href="#How32can32I32access32or32change32N32characters32of32a32string63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>You can access the first characters of a string with substr(). To get the first character, for example, start at position 0 and grab the string of length 1.</p>

                            </div>

                            <p>文字列の先頭の文字へは substr() でアクセスできます。 例えば、最初の文字を得るには、位置 0 から始めて、長さ 1 の文字列を 取得します。</p>

                            <pre class="prettyprint lang-perl"><code>        $string = &quot;Just another Perl Hacker&quot;;
        $first_char = substr( $string, 0, 1 );  #  &#39;J&#39;</code></pre>

                            <div class="original">

                                <p>To change part of a string, you can use the optional fourth argument which is the replacement string.</p>

                            </div>

                            <p>文字列の一部を変換するために、省略可能な 4 番目の引数として置き換える 文字列を指定できます。</p>

                            <pre class="prettyprint lang-perl"><code>        substr( $string, 13, 4, &quot;Perl 5.8.0&quot; );</code></pre>

                            <div class="original">

                                <p>You can also use substr() as an lvalue.</p>

                            </div>

                            <p>substr() を左辺値として使うこともできます。</p>

                            <pre class="prettyprint lang-perl"><code>        substr( $string, 13, 4 ) =  &quot;Perl 5.8.0&quot;;</code></pre>

                            <h2 id="How32do32I32change32the32Nth32occurrence32of32something63">何かの N 番目のものを変更するには?<a href="#How32do32I32change32the32Nth32occurrence32of32something63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>You have to keep track of N yourself. For example, let&#39;s say you want to change the fifth occurrence of <code>&quot;whoever&quot;</code> or <code>&quot;whomever&quot;</code> into <code>&quot;whosoever&quot;</code> or <code>&quot;whomsoever&quot;</code>, case insensitively. These all assume that $_ contains the string to be altered.</p>

                            </div>

                            <p>自分で N 番目の記録を取る必要があります。 例えば、(大小文字の違いを無視して) 5 番目に現れた <code>&quot;whoever&quot;</code> か <code>&quot;whomever&quot;</code> を <code>&quot;whosoever&quot;</code> か <code>&quot;whomsoever&quot;</code> に変更したいと考えているとしましょう。 以下は全て $_ に変更したい文字列が入っているものとします。</p>

                            <pre class="prettyprint lang-perl"><code>        $count = 0;
        s{((whom?)ever)}{
        ++$count == 5       # is it the 5th?
            ? &quot;${2}soever&quot;  # yes, swap
            : $1            # renege and leave it there
                }ige;</code></pre>

                            <div class="original">

                                <p>In the more general case, you can use the <code>/g</code> modifier in a <code>while</code> loop, keeping count of matches.</p>

                            </div>

                            <p>もっと一般的なケースでは、<code>while</code> ループの中で <code>/g</code> 修飾子を使ってマッチの数を数えることもできます。</p>

                            <pre class="prettyprint lang-perl"><code>        $WANT = 3;
        $count = 0;
        $_ = &quot;One fish two fish red fish blue fish&quot;;
        while (/(\w+)\s+fish\b/gi) {
                if (++$count == $WANT) {
                        print &quot;The third fish is a $1 one.\n&quot;;
                        }
                }</code></pre>

                            <div class="original">

                                <p>That prints out: <code>&quot;The third fish is a red one.&quot;</code> You can also use a repetition count and repeated pattern like this:</p>

                            </div>

                            <p>これは <code>&quot;The third fish is a red one.&quot;</code> のように出力します。 以下のようにパターンの繰り返し回数を指定するやり方もあります:</p>

                            <pre class="prettyprint lang-perl"><code>        /(?:\w+\s+fish\s+){2}(\w+)\s+fish/i;</code></pre>

                            <h2 id="How32can32I32count32the32number32of32occurrences32of32a32substring32within32a32string63">ある文字列の中に存在する部分文字列が何個あるのかを数えるには?<a href="#How32can32I32count32the32number32of32occurrences32of32a32substring32within32a32string63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the <code>tr///</code> function like so:</p>

                            </div>

                            <p>様々な効率を持った、いろいろなやり方があります。 文字列中に存在しているある単一キャラクター (X) の数を数えたいのであれば、 <code>tr///</code> 関数を使って次のようにできます:</p>

                            <pre class="prettyprint lang-perl"><code>        $string = &quot;ThisXlineXhasXsomeXx&#39;sXinXit&quot;;
        $count = ($string =~ tr/X//);
        print &quot;There are $count X characters in the string&quot;;</code></pre>

                            <div class="original">

                                <p>This is fine if you are just looking for a single character. However, if you are trying to count multiple character substrings within a larger string, <code>tr///</code> won&#39;t work. What you can do is wrap a while() loop around a global pattern match. For example, let&#39;s count negative integers:</p>

                            </div>

                            <p>これは単一キャラクターを対象にするのであればちょうどいいものですが、 大きな文字列中の、複数キャラクターから構成される部分文字列の数を 数えようとしても、<code>tr///</code> はうまく動作しません。 ここで可能なのは、グローバルなパターンマッチを while() で囲んでしまうという ものです。たとえば、負の数を数えるのならこうします:</p>

                            <pre class="prettyprint lang-perl"><code>        $string = &quot;-9 55 48 -2 23 -76 4 14 -44&quot;;
        while ($string =~ /-\d+/g) { $count++ }
        print &quot;There are $count negative numbers in the string&quot;;</code></pre>

                            <div class="original">

                                <p>Another version uses a global match in list context, then assigns the result to a scalar, producing a count of the number of matches.</p>

                            </div>

                            <p>もう一つのバージョンでは、リストコンテキストでグローバルマッチングを 使って、その結果をスカラに代入することで、マッチングした数を数えます。</p>

                            <pre class="prettyprint lang-perl"><code>        $count = () = $string =~ /-\d+/g;</code></pre>

                            <h2 id="Does32Perl32have32a32Year32203832problem63">Perl には 2038 年問題はありますか?<a href="#Does32Perl32have32a32Year32203832problem63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>No, all of Perl&#39;s built in date and time functions and modules will work to about 2 billion years before and after 1970.</p>

                            </div>

                            <p>いいえ、Perl 組み込みの日付時刻関数とモジュールの全ては 1970 年の 前後約 20 億年に対して正しく動作します。</p>

                            <div class="original">

                                <p>Many systems cannot count time past the year 2038. Older versions of Perl were dependent on the system to do date calculation and thus shared their 2038 bug.</p>

                            </div>

                            <p>多くのシステムでは 2038 年以降の時刻を数えられません。 古いバージョンの Perl では日付の計算を行うためにシステムに依存していたので、 システムの 2038 年バグを共有していました。</p>

                            <h2 id="How32do32I32capitalize32all32the32words32on32one32line63">一行にあるすべての単語をキャピタライズするには?<a href="#How32do32I32capitalize32all32the32words32on32one32line63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>Damian Conway&#39;s <a href="/pod/Text::Autoformat">Text::Autoformat</a> handles all of the thinking for you.</p>

                            </div>

                            <p>Damian Conway による <a href="/pod/Text::Autoformat">Text::Autoformat</a> は、考えるべき全てのことを 処理してくれます:</p>

                            <pre class="prettyprint lang-perl"><code>        use Text::Autoformat;
        my $x = &quot;Dr. Strangelove or: How I Learned to Stop &quot;.
          &quot;Worrying and Love the Bomb&quot;;

        print $x, &quot;\n&quot;;
        for my $style (qw( sentence title highlight )) {
                print autoformat($x, { case =&gt; $style }), &quot;\n&quot;;
                }</code></pre>

                            <div class="original">

                                <p>How do you want to capitalize those words?</p>

                            </div>

                            <p>これらの単語のキャピタライズはどうしたいですか?</p>

                            <pre class="prettyprint lang-perl"><code>        FRED AND BARNEY&#39;S LODGE        # all uppercase
        Fred And Barney&#39;s Lodge        # title case
        Fred and Barney&#39;s Lodge        # highlight case</code></pre>

                            <div class="original">

                                <p>It&#39;s not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you&#39;re right. Perl words are groups of <code>\w+</code>, but that&#39;s not what you want to capitalize. How is Perl supposed to know not to capitalize that <code>s</code> after the apostrophe? You could try a regular expression:</p>

                            </div>

                            <p>これは見た目ほど簡単な問題ではありません。 これらにはいくつの単語があると思いますか? 考え中…考え中…。 もし 5 と答えたなら、あなたは正しいです。 Perl での単語は <code>\w+</code> の集合ですが、これはあなたが キャピタライズしたいものではありません。 アポストロフィの後の <code>s</code> はキャピタライズしないように Perl に 知らせるには? 正規表現に挑戦してみましょう:</p>

                            <pre class="prettyprint lang-perl"><code>        $string =~ s/ (
                                 (^\w)    #at the beginning of the line
                                   |      # or
                                 (\s\w)   #preceded by whitespace
                                   )
                                /\U$1/xg;

        $string =~ s/([\w&#39;]+)/\u\L$1/g;</code></pre>

                            <div class="original">

                                <p>Now, what if you don&#39;t want to capitalize that &quot;and&quot;? Just use <a href="/pod/Text::Autoformat">Text::Autoformat</a> and get on with the next problem. :)</p>

                            </div>

                            <p>ここで、&quot;and&quot; をキャピタライズしないようにするには? <a href="/pod/Text::Autoformat">Text::Autoformat</a> を使って、次の問題に取り組んでください :)</p>

                            <h2 id="How32can32I32split32a32character93delimited32string32except32when32inside32character93">(とある文字)の内側にある時を除き、(とある文字)で終端されている文字列を分割するには?<a href="#How32can32I32split32a32character93delimited32string32except32when32inside32character93" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Several modules can handle this sort of parsing--<code>Text::Balanced</code>, <code>Text::CSV</code>, <code>Text::CSV_XS</code>, and <code>Text::ParseWords</code>, among others.</p>

                            </div>

                            <p>いくつかのモジュールがこのようなパースを扱います-- <code>Text::Balanced</code>, <code>Text::CSV</code>, <code>Text::CSV_XS</code>, <code>Text::ParseWords</code> などです。</p>

                            <div class="original">

                                <p>Take the example case of trying to split a string that is comma-separated into its different fields. You can&#39;t use <code>split(/,/)</code> because you shouldn&#39;t split if the comma is inside quotes. For example, take a data line like this:</p>

                            </div>

                            <p>カンマで分割された文字列を別々のフィールドに置くような例を 考えてみましょう。 ここで <code>split(/,/)</code> を使うことはできません。 なぜなら、クォートの内側にあるカンマで分割すべきではないからです。 例えば以下のようなデータを考えてみましょう。</p>

                            <pre class="prettyprint lang-perl"><code>        SAR001,&quot;&quot;,&quot;Cimetrix, Inc&quot;,&quot;Bob Smith&quot;,&quot;CAM&quot;,N,8,1,0,7,&quot;Error, Core Dumped&quot;</code></pre>

                            <div class="original">

                                <p>Due to the restriction of the quotes, this is a fairly complex problem. Thankfully, we have Jeffrey Friedl, author of <i>Mastering Regular Expressions</i>, to handle these for us. He suggests (assuming your string is contained in <code>$text</code>):</p>

                            </div>

                            <p>クォートの制約のためにこれは実に複雑な問題です。 ありがたいことに、私たちには <i>Mastering Regular Expressions</i> の著者でもあり、 この問題を私たちのために扱ってくれる Jeffrey Friedl がいます。 彼の提案はこうです(文字列が <code>$text</code> にあると仮定しています):</p>

                            <pre class="prettyprint lang-perl"><code>         @new = ();
         push(@new, $+) while $text =~ m{
                 &quot;([^\&quot;\\]*(?:\\.[^\&quot;\\]*)*)&quot;,?  # groups the phrase inside the quotes
                | ([^,]+),?
                | ,
                }gx;
         push(@new, undef) if substr($text,-1,1) eq &#39;,&#39;;</code></pre>

                            <div class="original">

                                <p>If you want to represent quotation marks inside a quotation-mark-delimited field, escape them with backslashes (eg, <code>&quot;like \&quot;this\&quot;&quot;</code>.</p>

                            </div>

                            <p>クォーテーションマークで終端されたフィールドの中で クォーテーションマークを表現したいのならば、 それをバックスラッシュで(<code>&quot;like \&quot;this\&quot;&quot;</code> のように)エスケープしてください。</p>

                            <div class="original">

                                <p>Alternatively, the <code>Text::ParseWords</code> module (part of the standard Perl distribution) lets you say:</p>

                            </div>

                            <p>あるいは、<code>Text::PaserWords</code> モジュール(標準 Perl 配布の一部です)を 使ってこうします:</p>

                            <pre class="prettyprint lang-perl"><code>        use Text::ParseWords;
        @new = quotewords(&quot;,&quot;, 0, $text);</code></pre>

                            <h2 id="How32do32I32strip32blank32space32from32the32beginning47end32of32a32string63">文字列の先頭や末尾にある空白を剥ぎ取るには?<a href="#How32do32I32strip32blank32space32from32the32beginning47end32of32a32string63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>A substitution can do this for you. For a single line, you want to replace all the leading or trailing whitespace with nothing. You can do that with a pair of substitutions.</p>

                            </div>

                            <p>置換を使うことで行えます。 1 行では、先頭か末尾のどちらかの空白全てを削除します。 2 つの置換でこれが行えます。</p>

                            <pre class="prettyprint lang-perl"><code>        s/^\s+//;
        s/\s+$//;</code></pre>

                            <div class="original">

                                <p>You can also write that as a single substitution, although it turns out the combined statement is slower than the separate ones. That might not matter to you, though.</p>

                            </div>

                            <p>これを 1 回の置換で書くこともできますが、組み合わせた文は分かれている 文よりも遅くなります。 しかし、それはあなたには問題がないかもしれません。</p>

                            <pre class="prettyprint lang-perl"><code>        s/^\s+|\s+$//g;</code></pre>

                            <div class="original">

                                <p>In this regular expression, the alternation matches either at the beginning or the end of the string since the anchors have a lower precedence than the alternation. With the <code>/g</code> flag, the substitution makes all possible matches, so it gets both. Remember, the trailing newline matches the <code>\s+</code>, and the <code>$</code> anchor can match to the physical end of the string, so the newline disappears too. Just add the newline to the output, which has the added benefit of preserving &quot;blank&quot; (consisting entirely of whitespace) lines which the <code>^\s+</code> would remove all by itself.</p>

                            </div>

                            <p>この正規表現において、アンカーは the alternation より低い優先順位を 持つので、the alternation は文字列の先頭か末尾にマッチングします。 <code>/g</code> フラグが付いていることにより、可能な全てのマッチングについて置換が 行われるので、先頭と末尾の両方で行われます。 引き続く改行は <code>\s+</code> にマッチングし、<code>$</code> アンカーは文字列の物理的な 末尾にマッチングするので、改行も消えることを忘れないでください。 単に出力に改行を追加することで、<code>^\s+</code> がすべて削除してしまう「空の」 (空白だけからなる)行を保存する利点が追加されます。</p>

                            <pre class="prettyprint lang-perl"><code>        while( &lt;&gt; )
                {
                s/^\s+|\s+$//g;
                print &quot;$_\n&quot;;
                }</code></pre>

                            <div class="original">

                                <p>For a multi-line string, you can apply the regular expression to each logical line in the string by adding the <code>/m</code> flag (for &quot;multi-line&quot;). With the <code>/m</code> flag, the <code>$</code> matches <i>before</i> an embedded newline, so it doesn&#39;t remove it. It still removes the newline at the end of the string.</p>

                            </div>

                            <p>複数行の文字列に対しては、<code>/m</code> (&quot;multi-line&quot;) フラグを追加することにより、 文字列中の論理行毎に正規表現を適用できます。 <code>/m</code> フラグをつけると、<code>$</code> 組み込まれた改行の <i>前に</i> マッチングするので、 これを取り除けません。 文字列の末尾の改行は取り除けます。</p>

                            <pre class="prettyprint lang-perl"><code>        $string =~ s/^\s+|\s+$//gm;</code></pre>

                            <div class="original">

                                <p>Remember that lines consisting entirely of whitespace will disappear, since the first part of the alternation can match the entire string and replace it with nothing. If need to keep embedded blank lines, you have to do a little more work. Instead of matching any whitespace (since that includes a newline), just match the other whitespace.</p>

                            </div>

                            <p>空白だけからなる文字列は、置換の最初の部分が文字列全体にマッチングして、 それを空文字列に置き換えてしまうので、消えてしまうことに注意してください。 もし組み込まれている空行を保存したいなら、さらにもう少し作業をする必要が あります。 全ての空白(改行を含みます)にマッチングさせる代わりに、単にその他の 空白にマッチングさせます。</p>

                            <pre class="prettyprint lang-perl"><code>        $string =~ s/^[\t\f ]+|[\t\f ]+$//mg;</code></pre>

                            <h2 id="How32do32I32pad32a32string32with32blanks32or32pad32a32number32with32zeroes63">文字列に空白をパッディングしたり、数値にゼロをパッディングしたりするには?<a href="#How32do32I32pad32a32string32with32blanks32or32pad32a32number32with32zeroes63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>In the following examples, <code>$pad_len</code> is the length to which you wish to pad the string, <code>$text</code> or <code>$num</code> contains the string to be padded, and <code>$pad_char</code> contains the padding character. You can use a single character string constant instead of the <code>$pad_char</code> variable if you know what it is in advance. And in the same way you can use an integer in place of <code>$pad_len</code> if you know the pad length in advance.</p>

                            </div>

                            <p>以下に挙げる例で、<code>$pad_len</code> はパッディングしたい文字列の長さです。 <code>$text</code> や <code>$num</code> は文字列にパッディングの対象となる内容を保持していて、 <code>$pad_char</code> がパッディングに使いたいキャラクターを保持しています。 やっていることがわかっているのなら、<code>$pad_char</code> という変数の代わりに一 文字のキャラクター文字列を使うこともできます。 そして同様に、パッディングしたい長さが予め分かっているなら、 <code>$pad_len</code> に整数値を指定することも出来ます。</p>

                            <div class="original">

                                <p>The simplest method uses the <code>sprintf</code> function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The <code>pack</code> function can only pad strings on the right with blanks and it will truncate the result to a maximum length of <code>$pad_len</code>.</p>

                            </div>

                            <p>最も単純なやり方は <code>sprintf</code> 関数を使うというものです。 この関数は文字列の左や右にパッディングを行ったり、0 を左に置いたりする ことができます。 <code>pack</code> 関数は文字列の右側に空白でパッディングすることと、 結果の最大長を <code>$pad_len</code> に切り詰めることだけができます。</p>

                            <pre class="prettyprint lang-perl"><code>        # Left padding a string with blanks (no truncation):
        $padded = sprintf(&quot;%${pad_len}s&quot;, $text);
        $padded = sprintf(&quot;%*s&quot;, $pad_len, $text);  # same thing

        # Right padding a string with blanks (no truncation):
        $padded = sprintf(&quot;%-${pad_len}s&quot;, $text);
        $padded = sprintf(&quot;%-*s&quot;, $pad_len, $text); # same thing

        # Left padding a number with 0 (no truncation):
        $padded = sprintf(&quot;%0${pad_len}d&quot;, $num);
        $padded = sprintf(&quot;%0*d&quot;, $pad_len, $num); # same thing

        # Right padding a string with blanks using pack (will truncate):
        $padded = pack(&quot;A$pad_len&quot;,$text);</code></pre>

                            <div class="original">

                                <p>If you need to pad with a character other than blank or zero you can use one of the following methods. They all generate a pad string with the <code>x</code> operator and combine that with <code>$text</code>. These methods do not truncate <code>$text</code>.</p>

                            </div>

                            <p>空白やゼロ以外のキャラクターでパッディングを行いたいのであれば、 以下に挙げるやり方を使うことができます。これらは全て パッディング文字列を <code>x</code> 修飾子で生成して <code>$text</code> と結合します。 これらのメソッドは <code>$text</code> を切り詰めません。</p>

                            <div class="original">

                                <p>Left and right padding with any character, creating a new string:</p>

                            </div>

                            <p>任意のキャラクターによる左詰めと右詰めを行い、新しい文字列を作ります:</p>

                            <pre class="prettyprint lang-perl"><code>        $padded = $pad_char x ( $pad_len - length( $text ) ) . $text;
        $padded = $text . $pad_char x ( $pad_len - length( $text ) );</code></pre>

                            <div class="original">

                                <p>Left and right padding with any character, modifying <code>$text</code> directly:</p>

                            </div>

                            <p>任意のキャラクターによる左詰めと右詰めを行い、<code>$text</code> を直接変更します:</p>

                            <pre class="prettyprint lang-perl"><code>        substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) );
        $text .= $pad_char x ( $pad_len - length( $text ) );</code></pre>

                            <h2 id="How32do32I32extract32selected32columns32from32a32string63">文字列から選択されたカラムを取り出すには?<a href="#How32do32I32extract32selected32columns32from32a32string63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>If you know where the columns that contain the data, you can use <code>substr</code> to extract a single column.</p>

                            </div>

                            <p>データが含まれている桁が分かっているなら、単一の桁を展開するために <code>substr</code> が使えます。</p>

                            <pre class="prettyprint lang-perl"><code>        my $column = substr( $line, $start_column, $length );</code></pre>

                            <div class="original">

                                <p>You can use <code>split</code> if the columns are separated by whitespace or some other delimiter, as long as whitespace or the delimiter cannot appear as part of the data.</p>

                            </div>

                            <p>桁が空白やその他のデリミタで分けられていて、データの一部としては 空白やデリミタが現れないなら、<code>split</code> が使えます。</p>

                            <pre class="prettyprint lang-perl"><code>        my $line    = &#39; fred barney   betty   &#39;;
        my @columns = split /\s+/, $line;
                # ( &#39;&#39;, &#39;fred&#39;, &#39;barney&#39;, &#39;betty&#39; );

        my $line    = &#39;fred||barney||betty&#39;;
        my @columns = split /\|/, $line;
                # ( &#39;fred&#39;, &#39;&#39;, &#39;barney&#39;, &#39;&#39;, &#39;betty&#39; );</code></pre>

                            <div class="original">

                                <p>If you want to work with comma-separated values, don&#39;t do this since that format is a bit more complicated. Use one of the modules that handle that format, such as <code>Text::CSV</code>, <code>Text::CSV_XS</code>, or <code>Text::CSV_PP</code>.</p>

                            </div>

                            <p>カンマ区切りの値(CSV)を扱いたい場合は、フォーマットが少し複雑なので これはしないで下さい。 <code>Text::CSV</code>, <code>Text::CSV_XS</code>, <code>Text::CSV_PP</code> のような、この フォーマットを扱うためのモジュールの一つを使ってください。</p>

                            <div class="original">

                                <p>If you want to break apart an entire line of fixed columns, you can use <code>unpack</code> with the A (ASCII) format. by using a number after the format specifier, you can denote the column width. See the <code>pack</code> and <code>unpack</code> entries in <a href="/pod/perlfunc">perlfunc</a> for more details.</p>

                            </div>

                            <p>固定桁の行全体を分解したいなら、<code>unpack</code> の A (ASCII) フォーマットが 使えます。 フォーマット指定子の後に数値をつけることで、桁数を指定できます。 更なる詳細については <a href="/pod/perlfunc">perlfunc</a> の <code>pack</code> と <code>unpack</code> の項目を 参照してください。</p>

                            <pre class="prettyprint lang-perl"><code>        my @fields = unpack( $line, &quot;A8 A8 A8 A16 A4&quot; );</code></pre>

                            <div class="original">

                                <p>Note that spaces in the format argument to <code>unpack</code> do not denote literal spaces. If you have space separated data, you may want <code>split</code> instead.</p>

                            </div>

                            <p><code>unpack</code> のフォーマット引数での空白はリテラルな空白を意味しないことに 注意してください。 もし空白で区切られたデータがあるなら、代わりに <code>split</code> を使ったほうが いいかもしれません。</p>

                            <h2 id="How32do32I32find32the32soundex32value32of32a32string63">文字列の soundex 値を見つけるには?<a href="#How32do32I32find32the32soundex32value32of32a32string63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>You can use the Text::Soundex module. If you want to do fuzzy or close matching, you might also try the <code>String::Approx</code>, and <code>Text::Metaphone</code>, and <code>Text::DoubleMetaphone</code> modules.</p>

                            </div>

                            <p>Text::Soundex モジュールが使えます。 あいまいマッチングや近傍マッチングを行いたいなら、 <code>String::Approx</code>, <code>Text::Metaphone</code>, <code>Text::DoubleMetaphone</code> といった モジュールを試すのも良いでしょう。</p>

                            <h2 id="How32can32I32expand32variables32in32text32strings63">テキスト文字列の中にある変数を展開するには?<a href="#How32can32I32expand32variables32in32text32strings63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>If you can avoid it, don&#39;t, or if you can use a templating system, such as <code>Text::Template</code> or <code>Template</code> Toolkit, do that instead. You might even be able to get the job done with <code>sprintf</code> or <code>printf</code>:</p>

                            </div>

                            <p>もし避けることが可能なら、してはいけません; あるいは、<code>Text::Template</code> や <code>Template</code> ツールキットのような テンプレートシステムが使えるなら、これらを代わりに使ってください。 <code>sprintf</code> や <code>printf</code> を使って作業をこなすことすらできます:</p>

                            <pre class="prettyprint lang-perl"><code>        my $string = sprintf &#39;Say hello to %s and %s&#39;, $foo, $bar;</code></pre>

                            <div class="original">

                                <p>However, for the one-off simple case where I don&#39;t want to pull out a full templating system, I&#39;ll use a string that has two Perl scalar variables in it. In this example, I want to expand <code>$foo</code> and <code>$bar</code> to their variable&#39;s values:</p>

                            </div>

                            <p>しかし、完全なテンプレートシステムを引っ張り出したくないような一度限りの 簡単な場合には、内部に二つの Perl スカラ変数を持つ文字列を使います。 この例では、<code>$foo</code> と <code>$bar</code> をその変数の値に展開したいとします:</p>

                            <pre class="prettyprint lang-perl"><code>        my $foo = &#39;Fred&#39;;
        my $bar = &#39;Barney&#39;;
        $string = &#39;Say hello to $foo and $bar&#39;;</code></pre>

                            <div class="original">

                                <p>One way I can do this involves the substitution operator and a double <code>/e</code> flag. The first <code>/e</code> evaluates <code>$1</code> on the replacement side and turns it into <code>$foo</code>. The second /e starts with <code>$foo</code> and replaces it with its value. <code>$foo</code>, then, turns into &#39;Fred&#39;, and that&#39;s finally what&#39;s left in the string:</p>

                            </div>

                            <p>これを行う一つの方法は、置換演算子と二つの <code>/e</code> フラグを使うものです。 一つ目の <code>/e</code> は置き換え側の <code>$1</code> を評価して <code>$foo</code> に変えます。 二つ目の <code>/e</code> は <code>$foo</code> をその値に変えます。 従って、<code>$foo</code> は &#39;Fred&#39; に変わって、それが結局最終的に文字列に 残されるものになります:</p>

                            <pre class="prettyprint lang-perl"><code>        $string =~ s/(\$\w+)/$1/eeg; # &#39;Say hello to Fred and Barney&#39;</code></pre>

                            <div class="original">

                                <p>The <code>/e</code> will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I&#39;m using the <code>/e</code> flag (twice even!), I have all of the same security problems I have with <code>eval</code> in its string form. If there&#39;s something odd in <code>$foo</code>, perhaps something like <code>@{[ system &quot;rm -rf /&quot; ]}</code>, then I could get myself in trouble.</p>

                            </div>

                            <p><code>/e</code> は暗黙のうちに struct 違反を無視するので、未定義の変数名を 空文字列に置き換えます。 <code>/e</code> フラグを (2 回も!) 使っているので、<code>eval</code> を文字列の形で使うのと 同じセキュリティ問題を全て抱えています。 もし <code>$foo</code> に(おそらく <code>@{[ system &quot;rm -rf /&quot; ]}</code> のような)変なものが 入っていたら、トラブルに出会うことになります。</p>

                            <div class="original">

                                <p>To get around the security problem, I could also pull the values from a hash instead of evaluating variable names. Using a single <code>/e</code>, I can check the hash to ensure the value exists, and if it doesn&#39;t, I can replace the missing value with a marker, in this case <code>???</code> to signal that I missed something:</p>

                            </div>

                            <p>セキュリティ問題を避けるために、変数名を評価するのではなくハッシュから 値を取ってくることもできます。 <code>/e</code> を一つ使って、ハッシュに値があることを確認し、もしなければ、 値をマーカーに置き換えます; この場合は、<code>???</code> が何かがおかしいことの 印です;</p>

                            <pre class="prettyprint lang-perl"><code>        my $string = &#39;This has $foo and $bar&#39;;

        my %Replacements = (
                foo  =&gt; &#39;Fred&#39;,
                );

        # $string =~ s/\$(\w+)/$Replacements{$1}/g;
        $string =~ s/\$(\w+)/
                exists $Replacements{$1} ? $Replacements{$1} : &#39;???&#39;
                /eg;

        print $string;</code></pre>

                            <h2 id="Whats32wrong32with32always32quoting32vars63">常にクォーティング "$vars" することの何が悪いの?<a href="#Whats32wrong32with32always32quoting32vars63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don&#39;t want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</p>

                            </div>

                            <p>そういったダブルクォートが、強制的に文字列化(stringification)するのが問題で、 たとえそれを望んでいなくても数値やリファレンスが強制的に 文字列に変換されてしまうのです。 このように考えましょう: ダブルクォートは新しい文字列を生成するのに使われる。 もしあなたがすでに文字列を持っているのであれば、使う必要が あるでしょうか?</p>

                            <div class="original">

                                <p>If you get used to writing odd things like these:</p>

                            </div>

                            <p>以下の例のような変な書き方をすると:</p>

                            <pre class="prettyprint lang-perl"><code>        print &quot;$var&quot;;           # BAD
        $new = &quot;$old&quot;;          # BAD
        somefunc(&quot;$var&quot;);       # BAD</code></pre>

                            <div class="original">

                                <p>You&#39;ll be in trouble. Those should (in 99.8% of the cases) be the simpler and more direct:</p>

                            </div>

                            <p>あなたはトラブルに巻き込まれることになるでしょう。 これらは(99.8% は)、より単純、かつより直接的に書くべきなのです。</p>

                            <pre class="prettyprint lang-perl"><code>        print $var;
        $new = $old;
        somefunc($var);</code></pre>

                            <div class="original">

                                <p>Otherwise, besides slowing you down, you&#39;re going to break code when the thing in the scalar is actually neither a string nor a number, but a reference:</p>

                            </div>

                            <p>さもなければ、プログラムを遅くなることのほかにも、スカラが実際には文字列でも 数値でもなくリファレンスであるようなときにあなたのプログラムが おかしくなることになります。</p>

                            <pre class="prettyprint lang-perl"><code>        func(\@array);
        sub func {
                my $aref = shift;
                my $oref = &quot;$aref&quot;;  # WRONG
                }</code></pre>

                            <div class="original">

                                <p>You can also get into subtle problems on those few operations in Perl that actually do care about the difference between a string and a number, such as the magical <code>++</code> autoincrement operator or the syscall() function.</p>

                            </div>

                            <p>マジカル <code>++</code> オートインクリメント演算子や syscall() 関数のような、 文字列と数値の間の違いを実際に気にするような Perl の幾つかの操作において、 微妙な問題に直面するかもしれません。</p>

                            <div class="original">

                                <p>Stringification also destroys arrays.</p>

                            </div>

                            <p>文字列化(stringfication)も配列を壊します。</p>

                            <pre class="prettyprint lang-perl"><code>        @lines = `command`;
        print &quot;@lines&quot;;     # WRONG - extra blanks
        print @lines;       # right</code></pre>

                            <h2 id="Why32dont32my32HERE32documents32work63">なぜ私の <<HERE ドキュメントがうまく動かないのでしょう?<a href="#Why32dont32my32HERE32documents32work63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Check for these three things:</p>

                            </div>

                            <p>以下の三つの点を確認してください。</p>

                            <dl>

                                <dt>There must be no space after the &lt;&lt; part.</dt>
                                <dd>

                                    <p>(&lt;&lt; パートの後ろに空白があってはいけません。)</p>

                                </dd>
                                <dt>There (probably) should be a semicolon at the end.</dt>
                                <dd>

                                    <p>(終端にセミコロンが置かれているかもしれません。)</p>

                                </dd>
                                <dt>You can&#39;t (easily) have any space in front of the tag.</dt>
                                <dd>

                                    <p>(タグの前に任意のスペースを置くことはできません。)</p>

                                </dd>
                            </dl>

                            <div class="original">

                                <p>If you want to indent the text in the here document, you can do this:</p>

                            </div>

                            <p>ヒアドキュメントのテキストでインデントを使いたいのであれば、 以下のようにしてできます:</p>

                            <pre class="prettyprint lang-perl"><code>    # all in one
    ($VAR = &lt;&lt;HERE_TARGET) =~ s/^\s+//gm;
        your text
        goes here
    HERE_TARGET</code></pre>

                            <div class="original">

                                <p>But the HERE_TARGET must still be flush against the margin. If you want that indented also, you&#39;ll have to quote in the indentation.</p>

                            </div>

                            <p>しかしこの場合も HERE_TARGET は先頭に置かなければなりません。 もしこれもインデントしたいのなら、インデントをクォートする必要があるでしょう。</p>

                            <pre class="prettyprint lang-perl"><code>    ($quote = &lt;&lt;&#39;    FINIS&#39;) =~ s/^\s+//gm;
            ...we will have peace, when you and all your works have
            perished--and the works of your dark master to whom you
            would deliver us. You are a liar, Saruman, and a corrupter
            of men&#39;s hearts.  --Theoden in /usr/src/perl/taint.c
        FINIS
    $quote =~ s/\s+--/\n--/;</code></pre>

                            <div class="original">

                                <p>A nice general-purpose fixer-upper function for indented here documents follows. It expects to be called with a here document as its argument. It looks to see whether each line begins with a common substring, and if so, strips that substring off. Otherwise, it takes the amount of leading whitespace found on the first line and removes that much off each subsequent line.</p>

                            </div>

                            <p>以下はインデントされたヒアドキュメントのための汎用 fixer-upper 関数です。 この関数は引数にヒアドキュメントを渡されることを期待しています。 これは共通の部分文字列で始まる各行について、 その部分文字列を剥ぎ取るということを行います。 あるいは、最初の行の先頭にある空白を取り、 続く行に対しても同じ様に削除を行います。</p>

                            <pre class="prettyprint lang-perl"><code>    sub fix {
        local $_ = shift;
        my ($white, $leader);  # common whitespace and common leading string
        if (/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/) {
            ($white, $leader) = ($2, quotemeta($1));
        } else {
            ($white, $leader) = (/^(\s+)/, &#39;&#39;);
        }
        s/^\s*?$leader(?:$white)?//gm;
        return $_;
    }</code></pre>

                            <div class="original">

                                <p>This works with leading special strings, dynamically determined:</p>

                            </div>

                            <p>この関数は先頭にある特別な、動的に決められる文字列に対しても使えます:</p>

                            <pre class="prettyprint lang-perl"><code>        $remember_the_main = fix&lt;&lt;&#39;    MAIN_INTERPRETER_LOOP&#39;;
        @@@ int
        @@@ runops() {
        @@@     SAVEI32(runlevel);
        @@@     runlevel++;
        @@@     while ( op = (*op-&gt;op_ppaddr)() );
        @@@     TAINT_NOT;
        @@@     return 0;
        @@@ }
        MAIN_INTERPRETER_LOOP</code></pre>

                            <div class="original">

                                <p>Or with a fixed amount of leading whitespace, with remaining indentation correctly preserved:</p>

                            </div>

                            <p>また、先頭にある特定の個数の空白を取り除いて、インデントを 正しく残すようなこともできます:</p>

                            <pre class="prettyprint lang-perl"><code>        $poem = fix&lt;&lt;EVER_ON_AND_ON;
       Now far ahead the Road has gone,
          And I must follow, if I can,
       Pursuing it with eager feet,
          Until it joins some larger way
       Where many paths and errands meet.
          And whither then? I cannot say.
                --Bilbo in /usr/src/perl/pp_ctl.c
        EVER_ON_AND_ON</code></pre>

                            <h1 id="Data:32Arrays">データ: 配列<a href="#Data:32Arrays" class="toc_link">&#182;</a></h1>

                            <p></p>

                            <h2 id="What32is32the32difference32between32a32list32and32an32array63">リストと配列の差とはなんですか?<a href="#What32is32the32difference32between32a32list32and32an32array63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>An array has a changeable length. A list does not. An array is something you can push or pop, while a list is a set of values. Some people make the distinction that a list is a value while an array is a variable. Subroutines are passed and return lists, you put things into list context, you initialize arrays with lists, and you <code>foreach()</code> across a list. <code>@</code> variables are arrays, anonymous arrays are arrays, arrays in scalar context behave like the number of elements in them, subroutines access their arguments through the array <code>@_</code>, and <code>push</code>/<code>pop</code>/<code>shift</code> only work on arrays.</p>

                            </div>

                            <p>配列は長さを変えることができます。リストはできません。 ある配列に対して push や pop ができますが、 リストに対しては値のセットしかできません。 一部には配列が変数であるのに対してリストは値であると 区別して考えている人達もいます。 リストを受け取ったり返したりするサブルーチンはリストコンテキストに あなたを導き、リストで配列を初期化したり、<code>foreach()</code> でリストを辿ったりできます。 <code>@</code>変数は配列であり、無名配列も配列です。スカラコンテキストの配列は その要素数のように振る舞います。 サブルーチンはその引数を <code>@_</code> という配列を通してアクセスし、 <code>push</code>/<code>pop</code>/<code>shift</code> は配列に対してのみ働きます。</p>

                            <div class="original">

                                <p>As a side note, there&#39;s no such thing as a list in scalar context. When you say</p>

                            </div>

                            <p>スカラコンテキストでリストとして振る舞うものはないということに 注意してください。 以下のようにすると:</p>

                            <pre class="prettyprint lang-perl"><code>        $scalar = (2, 5, 7, 9);</code></pre>

                            <div class="original">

                                <p>you&#39;re using the comma operator in scalar context, so it uses the scalar comma operator. There never was a list there at all! This causes the last value to be returned: 9.</p>

                            </div>

                            <p>スカラコンテキストでカンマ演算子を使ったものであり、 スカラカンマ演算子を使います。 これはリストでもなんでもありません! この結果は最後の値である 9 となります。</p>

                            <h2 id="What32is32the32difference32between32array91193and32array91193">$array[1] と @array[1] との間の違いはなんですか?<a href="#What32is32the32difference32between32array91193and32array91193" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>The former is a scalar value; the latter an array slice, making it a list with one (scalar) value. You should use $ when you want a scalar value (most of the time) and @ when you want a list with one scalar value in it (very, very rarely; nearly never, in fact).</p>

                            </div>

                            <p>前者はスカラ値であり、後者は一つのスカラ値を持ったリストを構成する 配列のスライスです。スカラ値を必要とするならば(ほとんど の場合がこうでしょう)$を使うべきで、@ は一つのスカラ値を持った リストを必要とするとき(実際のところ、この状況は非常に希でしょう) に使うべきものです。</p>

                            <div class="original">

                                <p>Sometimes it doesn&#39;t make a difference, but sometimes it does. For example, compare:</p>

                            </div>

                            <p>これらはあるときには違いがありませんが、違いがでる場合もあります。 例えば以下のものを:</p>

                            <pre class="prettyprint lang-perl"><code>        $good[0] = `some program that outputs several lines`;</code></pre>

                            <div class="original">

                                <p>with</p>

                            </div>

                            <p>次のものと比較する場合です:</p>

                            <pre class="prettyprint lang-perl"><code>        @bad[0]  = `same program that outputs several lines`;</code></pre>

                            <div class="original">

                                <p>The <code>use warnings</code> pragma and the <b>-w</b> flag will warn you about these matters.</p>

                            </div>

                            <p><code>use warnings</code> プラグマと <b>-w</b> フラグはこのことに関する警告を行います。</p>

                            <h2 id="How32can32I32remove32duplicate32elements32from32a32list32or32array63">配列やリストにある重複した要素を削除するには?<a href="#How32can32I32remove32duplicate32elements32from32a32list32or32array63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>Use a hash. When you think the words &quot;unique&quot; or &quot;duplicated&quot;, think &quot;hash keys&quot;.</p>

                            </div>

                            <p>ハッシュを使ってください。 「ユニーク」や「重複」といった単語を考えたときには、 「ハッシュキー」を考えてください。</p>

                            <div class="original">

                                <p>If you don&#39;t care about the order of the elements, you could just create the hash then extract the keys. It&#39;s not important how you create that hash: just that you use <code>keys</code> to get the unique elements.</p>

                            </div>

                            <p>要素の順番を気にしないなら、単にハッシュを作ってキーを取り出してください。 どのようにハッシュを作るかは重要ではありません: 単にユニークな要素を取り出すために <code>keys</code> を使うためです。</p>

                            <pre class="prettyprint lang-perl"><code>        my %hash   = map { $_, 1 } @array;
        # or a hash slice: @hash{ @array } = ();
        # or a foreach: $hash{$_} = 1 foreach ( @array );

        my @unique = keys %hash;</code></pre>

                            <div class="original">

                                <p>If you want to use a module, try the <code>uniq</code> function from <code>List::MoreUtils</code>. In list context it returns the unique elements, preserving their order in the list. In scalar context, it returns the number of unique elements.</p>

                            </div>

                            <p>モジュールを使いたいなら、<code>List::MoreUtils</code> の <code>uniq</code> 関数を 試してみてください。 リストコンテキストでは、リストの順序を保存した形でユニークな要素を返します。 スカラコンテキストでは、ユニークな要素の数を返します。</p>

                            <pre class="prettyprint lang-perl"><code>        use List::MoreUtils qw(uniq);

        my @unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 1,2,3,4,5,6,7
        my $unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 7</code></pre>

                            <div class="original">

                                <p>You can also go through each element and skip the ones you&#39;ve seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in <code>%Seen</code>. The <code>next</code> statement creates the key and immediately uses its value, which is <code>undef</code>, so the loop continues to the <code>push</code> and increments the value for that key. The next time the loop sees that same element, its key exists in the hash <i>and</i> the value for that key is true (since it&#39;s not 0 or <code>undef</code>), so the next skips that iteration and the loop goes to the next element.</p>

                            </div>

                            <p>各要素を調べて、一度見つけたものをスキップすることもできます。 記録をつけるためにハッシュを使います。 ループが最初に要素を見つけると、この要素は <code>%Seen</code> にキーがありません。 <code>next</code> 文はキーを作り、直ちにその値(<code>undef</code>)を使うので、 ループは <code>push</code> を続行し、このキーの値をインクリメントします。 次回にループが同じ要素を見つけると、ハッシュにはそのキーが存在し、 <i>かつ</i> そのキーの値が(0 でも <code>undef</code> でもないので)真なので、 next は反復をスキップし、ループは次の要素に進みます。</p>

                            <pre class="prettyprint lang-perl"><code>        my @unique = ();
        my %seen   = ();

        foreach my $elem ( @array )
                {
                next if $seen{ $elem }++;
                push @unique, $elem;
                }</code></pre>

                            <div class="original">

                                <p>You can write this more briefly using a grep, which does the same thing.</p>

                            </div>

                            <p>grep を使うことでより簡単に書くこともでき、これは同じことになります。</p>

                            <pre class="prettyprint lang-perl"><code>        my %seen = ();
        my @unique = grep { ! $seen{ $_ }++ } @array;</code></pre>

                            <h2 id="How32can32I32tell32whether32a32certain32element32is32contained32in32a32list32or32array63">リストや配列の内容にある特定の要素があるかどうかを確かめるには?<a href="#How32can32I32tell32whether32a32certain32element32is32contained32in32a32list32or32array63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(portions of this answer contributed by Anno Siegel and brian d foy)</p>

                            </div>

                            <p>(この回答の一部は Anno Siegel と brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>Hearing the word &quot;in&quot; is an <i>in</i>dication that you probably should have used a hash, not a list or array, to store your data. Hashes are designed to answer this question quickly and efficiently. Arrays aren&#39;t.</p>

                            </div>

                            <p>ハッシュはこの質問に対する速くて効率の良い解答のために デザインされています。 配列はそうではありません。</p>

                            <div class="original">

                                <p>That being said, there are several ways to approach this. In Perl 5.10 and later, you can use the smart match operator to check that an item is contained in an array or a hash:</p>

                            </div>

                            <p>幾つかのやり方があります。 Perl 5.10 以降では、アイテムが配列やハッシュに含まれているかを チェックするのにスマートマッチング演算子が使えます:</p>

                            <pre class="prettyprint lang-perl"><code>        use 5.010;

        if( $item ~~ @array )
                {
                say &quot;The array contains $item&quot;
                }

        if( $item ~~ %hash )
                {
                say &quot;The hash contains $item&quot;
                }</code></pre>

                            <div class="original">

                                <p>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array&#39;s values:</p>

                            </div>

                            <p>以前のバージョンの Perl では、もう少し作業が必要です。 この問い合わせを多くのアイテムに対して 行いたいとか、値が任意の文字列である場合には最も速いやり方は元の 配列の逆のものを作って元の配列の値をキーとするようなハッシュを 管理するというものです:</p>

                            <pre class="prettyprint lang-perl"><code>        @blues = qw/azure cerulean teal turquoise lapis-lazuli/;
        %is_blue = ();
        for (@blues) { $is_blue{$_} = 1 }</code></pre>

                            <div class="original">

                                <p>Now you can check whether <code>$is_blue{$some_color}</code>. It might have been a good idea to keep the blues all in a hash in the first place.</p>

                            </div>

                            <p>こうすれば、<code>$is_blue{$some_color}</code> がどうであるかでチェックできます。 最初の場所で bules にハッシュのすべてを保持させるのはよい考えでしょう。</p>

                            <div class="original">

                                <p>If the values are all small integers, you could use a simple indexed array. This kind of an array will take up less space:</p>

                            </div>

                            <p>値のすべてが小さな整数であれば、単純な添え字付き配列を使うことができます。 この種の配列はより少ない場所しか使いません。</p>

                            <pre class="prettyprint lang-perl"><code>        @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
        @is_tiny_prime = ();
        for (@primes) { $is_tiny_prime[$_] = 1 }
        # or simply  @istiny_prime[@primes] = (1) x @primes;</code></pre>

                            <div class="original">

                                <p>Now you check whether $is_tiny_prime[$some_number].</p>

                            </div>

                            <p>これで $is_tiny_prime[$some_number] の内容がどうであるかで チェックできます。</p>

                            <div class="original">

                                <p>If the values in question are integers instead of strings, you can save quite a lot of space by using bit strings instead:</p>

                            </div>

                            <p>問い合わせる値が文字列ではなく整数であるのならば、ビットストリングを 使うことによって大幅に空間を節約することができます。</p>

                            <pre class="prettyprint lang-perl"><code>        @articles = ( 1..10, 150..2000, 2017 );
        undef $read;
        for (@articles) { vec($read,$_,1) = 1 }</code></pre>

                            <div class="original">

                                <p>Now check whether <code>vec($read,$n,1)</code> is true for some <code>$n</code>.</p>

                            </div>

                            <p>これで <code>vec($read,$n,1)</code> が真かどうかで <code>$n</code> の検査ができます。</p>

                            <div class="original">

                                <p>These methods guarantee fast individual tests but require a re-organization of the original list or array. They only pay off if you have to test multiple values against the same array.</p>

                            </div>

                            <p>これらのメソッドは個々のテストの速さが保証されていますが、 元のリストや配列の再構成が必要です。 同じ配列に対して複数の値をテストする必要がある場合にのみ元が取れます。</p>

                            <div class="original">

                                <p>If you are testing only once, the standard module <code>List::Util</code> exports the function <code>first</code> for this purpose. It works by stopping once it finds the element. It&#39;s written in C for speed, and its Perl equivalent looks like this subroutine:</p>

                            </div>

                            <p>一度だけテストする場合、標準モジュール <code>List::Util</code> がこの目的のために <code>first</code> 関数をエクスポートしています。 これは要素を見つけると停止することで動作します。 速度のために C で書かれていて、これの Perl の等価な処理は、次のサブルーチンの ようになります:</p>

                            <pre class="prettyprint lang-perl"><code>        sub first (&amp;@) {
                my $code = shift;
                foreach (@_) {
                        return $_ if &amp;{$code}();
                }
                undef;
        }</code></pre>

                            <div class="original">

                                <p>If speed is of little concern, the common idiom uses grep in scalar context (which returns the number of items that passed its condition) to traverse the entire list. This does have the benefit of telling you how many matches it found, though.</p>

                            </div>

                            <p>速度が問題ではないなら、一般的な方法は、リスト全体をトラバースするために grep をスカラコンテキストで使う(これで条件をパスしたアイテムの数を返します) ことです。 しかし、これには何回マッチングしたのかを知らせるという利点があります。</p>

                            <pre class="prettyprint lang-perl"><code>        my $is_there = grep $_ eq $whatever, @array;</code></pre>

                            <div class="original">

                                <p>If you want to actually extract the matching elements, simply use grep in list context.</p>

                            </div>

                            <p>実際にマッチングした要素を展開したい場合は、単にリストコンテキストで grep を使ってください。</p>

                            <pre class="prettyprint lang-perl"><code>        my @matches = grep $_ eq $whatever, @array;</code></pre>

                            <h2 id="How32do32I32compute32the32difference32of32two32arrays63How32do32I32compute32the32intersection32of32two32arrays63">二つの配列の差(difference)を求めるには? 二つの配列の共通要素(inter section)を求めるには?<a href="#How32do32I32compute32the32difference32of32two32arrays63How32do32I32compute32the32intersection32of32two32arrays63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Use a hash. Here&#39;s code to do both and more. It assumes that each element is unique in a given array:</p>

                            </div>

                            <p>ハッシュを使います。 以下のプログラム片は質問の両方を行います。 与えられた配列の要素には重複がないと仮定しています。</p>

                            <pre class="prettyprint lang-perl"><code>        @union = @intersection = @difference = ();
        %count = ();
        foreach $element (@array1, @array2) { $count{$element}++ }
        foreach $element (keys %count) {
                push @union, $element;
                push @{ $count{$element} &gt; 1 ? \@intersection : \@difference }, $element;
                }</code></pre>

                            <div class="original">

                                <p>Note that this is the <i>symmetric difference</i>, that is, all elements in either A or in B but not in both. Think of it as an xor operation.</p>

                            </div>

                            <p>これは <i>対称的差分</i>、つまり、A か B のどちらかにあって、 両方にあることはない全ての要素である、ということに注意してください。 これは xor 操作のようなものと考えてください。</p>

                            <h2 id="How32do32I32test32whether32two32arrays32or32hashes32are32equal63">二つの配列や二つのハッシュが等しいかどうかを検査するには?<a href="#How32do32I32test32whether32two32arrays32or32hashes32are32equal63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</p>

                            </div>

                            <p>Perl 5.10 以降では、スマートマッチング演算子が最小の作業で答えを 与えてくれます:</p>

                            <pre class="prettyprint lang-perl"><code>        use 5.010;

        if( @array1 ~~ @array2 )
                {
                say &quot;The arrays are the same&quot;;
                }

        if( %hash1 ~~ %hash2 ) # doesn&#39;t check values!
                {
                say &quot;The hash keys are the same&quot;;
                }</code></pre>

                            <div class="original">

                                <p>The following code works for single-level arrays. It uses a stringwise comparison, and does not distinguish defined versus undefined empty strings. Modify if you have other needs.</p>

                            </div>

                            <p>以下に挙げる例は一レベルの配列に対して有効です。 これは文字列としての比較を使い、定義済みと未定義の空文字列を区別しません。 必要に応じて修正してください。</p>

                            <pre class="prettyprint lang-perl"><code>        $are_equal = compare_arrays(\@frogs, \@toads);

        sub compare_arrays {
                my ($first, $second) = @_;
                no warnings;  # silence spurious -w undef complaints
                return 0 unless @$first == @$second;
                for (my $i = 0; $i &lt; @$first; $i++) {
                        return 0 if $first-&gt;[$i] ne $second-&gt;[$i];
                        }
                return 1;
                }</code></pre>

                            <div class="original">

                                <p>For multilevel structures, you may wish to use an approach more like this one. It uses the CPAN module <code>FreezeThaw</code>:</p>

                            </div>

                            <p>多重レベル構造に対応するために、あなたは以下のような手段を使いたいと 考えるかもしれません。 ここでは CPAN モジュールの <code>FreezeThaw</code> を使っています:</p>

                            <pre class="prettyprint lang-perl"><code>        use FreezeThaw qw(cmpStr);
        @a = @b = ( &quot;this&quot;, &quot;that&quot;, [ &quot;more&quot;, &quot;stuff&quot; ] );

        printf &quot;a and b contain %s arrays\n&quot;,
                cmpStr(\@a, \@b) == 0
                ? &quot;the same&quot;
                : &quot;different&quot;;</code></pre>

                            <div class="original">

                                <p>This approach also works for comparing hashes. Here we&#39;ll demonstrate two different answers:</p>

                            </div>

                            <p>このアプローチはハッシュの比較にも使えます。 以下に二種類の回答をお見せしましょう:</p>

                            <pre class="prettyprint lang-perl"><code>        use FreezeThaw qw(cmpStr cmpStrHard);

        %a = %b = ( &quot;this&quot; =&gt; &quot;that&quot;, &quot;extra&quot; =&gt; [ &quot;more&quot;, &quot;stuff&quot; ] );
        $a{EXTRA} = \%b;
        $b{EXTRA} = \%a;

        printf &quot;a and b contain %s hashes\n&quot;,
        cmpStr(\%a, \%b) == 0 ? &quot;the same&quot; : &quot;different&quot;;

        printf &quot;a and b contain %s hashes\n&quot;,
        cmpStrHard(\%a, \%b) == 0 ? &quot;the same&quot; : &quot;different&quot;;</code></pre>

                            <div class="original">

                                <p>The first reports that both those the hashes contain the same data, while the second reports that they do not. Which you prefer is left as an exercise to the reader.</p>

                            </div>

                            <p>最初のものは二つのハッシュが同じ内容であると報告しますが、二番目の ものは違うと報告します。</p>

                            <h2 id="How32do32I32find32the32first32array32element32for32which32a32condition32is32true63">ある条件が真となる最初の配列要素を見つけだすには?<a href="#How32do32I32find32the32first32array32element32for32which32a32condition32is32true63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>To find the first array element which satisfies a condition, you can use the <code>first()</code> function in the <code>List::Util</code> module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</p>

                            </div>

                            <p>条件を満たす最初の配列要素を探すためには、Perl 5.8 から同梱されている <code>List::Util</code> モジュールの <code>first()</code> 関数が使えます。 この例は &quot;Perl&quot; を含む最初の要素を探します。</p>

                            <pre class="prettyprint lang-perl"><code>        use List::Util qw(first);

        my $element = first { /Perl/ } @array;</code></pre>

                            <div class="original">

                                <p>If you cannot use <code>List::Util</code>, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</p>

                            </div>

                            <p><code>List::Util</code> が使えない場合は、同じことをするために自分でループを書きます。 要素が見つかったら、last を使ってループを停止します。</p>

                            <pre class="prettyprint lang-perl"><code>        my $found;
        foreach ( @array ) {
                if( /Perl/ ) { $found = $_; last }
                }</code></pre>

                            <div class="original">

                                <p>If you want the array index, you can iterate through the indices and check the array element at each index until you find one that satisfies the condition.</p>

                            </div>

                            <p>配列の添え字がほしい場合は、添え字に順番に変えていって、 それぞれの添え字の配列要素をチェックして、条件を満たすものが 見つかるまで繰り返します。</p>

                            <pre class="prettyprint lang-perl"><code>        my( $found, $index ) = ( undef, -1 );
        for( $i = 0; $i &lt; @array; $i++ ) {
                if( $array[$i] =~ /Perl/ ) {
                        $found = $array[$i];
                        $index = $i;
                        last;
                        }
                }</code></pre>

                            <h2 id="How32do32I32handle32linked32lists63">リンク付きリストを扱うには?<a href="#How32do32I32handle32linked32lists63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>In general, you usually don&#39;t need a linked list in Perl, since with regular arrays, you can push and pop or shift and unshift at either end, or you can use splice to add and/or remove arbitrary number of elements at arbitrary points. Both pop and shift are O(1) operations on Perl&#39;s dynamic arrays. In the absence of shifts and pops, push in general needs to reallocate on the order every log(N) times, and unshift will need to copy pointers each time.</p>

                            </div>

                            <p>一般的には、Perl ではリンク付きリストを扱う必要はありません。 なぜなら、通常の配列を使って push や pop、shift や unsift を使って両端で 操作できたり、splice を使って任意の場所にある任意個の要素を加えたり 削除したりすることができるからです。 pop と shift は両方ともが、Perl の動的配列に対する O(1) の操作です。 shift や pop がなかった場合、push は一般的には log(N) 回毎のオーダーで 再割り当てが必要になります。 そして unshift は呼ばれる毎にポインターのコピーが必要になるでしょう。</p>

                            <div class="original">

                                <p>If you really, really wanted, you could use structures as described in <a href="/pod/perldsc">perldsc</a> or <a href="/pod/perltoot">perltoot</a> and do just what the algorithm book tells you to do. For example, imagine a list node like this:</p>

                            </div>

                            <p>もし、本当に、本当にリンク付きリストを使いたいのなら、<a href="/pod/perldsc">perldsc</a> や <a href="/pod/perltoot">perltoot</a> で説明されているようなデータ構造を使うことができ、 アルゴリズムの教科書にあるようなことができます。 例えば以下のようなリストノードをを考えてみましょう:</p>

                            <pre class="prettyprint lang-perl"><code>        $node = {
                VALUE =&gt; 42,
                LINK  =&gt; undef,
                };</code></pre>

                            <div class="original">

                                <p>You could walk the list this way:</p>

                            </div>

                            <p>リストを渡り歩くには以下のようにします:</p>

                            <pre class="prettyprint lang-perl"><code>        print &quot;List: &quot;;
        for ($node = $head;  $node; $node = $node-&gt;{LINK}) {
                print $node-&gt;{VALUE}, &quot; &quot;;
                }
        print &quot;\n&quot;;</code></pre>

                            <div class="original">

                                <p>You could add to the list this way:</p>

                            </div>

                            <p>以下のやり方でリストに追加できます:</p>

                            <pre class="prettyprint lang-perl"><code>        my ($head, $tail);
        $tail = append($head, 1);       # grow a new head
        for $value ( 2 .. 10 ) {
                $tail = append($tail, $value);
                }

        sub append {
                my($list, $value) = @_;
                my $node = { VALUE =&gt; $value };
                if ($list) {
                        $node-&gt;{LINK} = $list-&gt;{LINK};
                        $list-&gt;{LINK} = $node;
                        }
                else {
                        $_[0] = $node;      # replace caller&#39;s version
                        }
                return $node;
                }</code></pre>

                            <div class="original">

                                <p>But again, Perl&#39;s built-in are virtually always good enough.</p>

                            </div>

                            <p>しかし繰り返しますが、Perl の組み込み型は事実上常に充分なものなのです。</p>

                            <h2 id="How32do32I32handle32circular32lists63">循環リストを扱うには?<a href="#How32do32I32handle32circular32lists63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>If you want to cycle through an array endlessy, you can increment the index modulo the number of elements in the array:</p>

                            </div>

                            <p>配列を無限に循環したいなら、配列の添え字をインクリメントして 要素数の剰余を取ったものを使います:</p>

                            <pre class="prettyprint lang-perl"><code>        my @array = qw( a b c );
        my $i = 0;

        while( 1 ) {
                print $array[ $i++ % @array ], &quot;\n&quot;;
                last if $i &gt; 20;
                }</code></pre>

                            <div class="original">

                                <p>You can also use <code>Tie::Cycle</code> to use a scalar that always has the next element of the circular array:</p>

                            </div>

                            <p>常に循環配列の次の要素をもつスカラを使うための、 <code>Tie::Cycle</code> を使うこともできます:</p>

                            <pre class="prettyprint lang-perl"><code>        use Tie::Cycle;

        tie my $cycle, &#39;Tie::Cycle&#39;, [ qw( FFFFFF 000000 FFFF00 ) ];

        print $cycle; # FFFFFF
        print $cycle; # 000000
        print $cycle; # FFFF00</code></pre>

                            <div class="original">

                                <p>The <code>Array::Iterator::Circular</code> creates an iterator object for circular arrays:</p>

                            </div>

                            <p><code>Array::Iterator::Circular</code> は循環配列のための反復子オブジェクトを 作ります:</p>

                            <pre class="prettyprint lang-perl"><code>        use Array::Iterator::Circular;

        my $color_iterator = Array::Iterator::Circular-&gt;new(
                qw(red green blue orange)
                );

        foreach ( 1 .. 20 ) {
                print $color_iterator-&gt;next, &quot;\n&quot;;
                }</code></pre>

                            <h2 id="How32do32I32shuffle32an32array32randomly63">配列をランダムにかき混ぜるには?<a href="#How32do32I32shuffle32an32array32randomly63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>If you either have Perl 5.8.0 or later installed, or if you have Scalar-List-Utils 1.03 or later installed, you can say:</p>

                            </div>

                            <p>Perl 5.8.0 以降がインストールされているか、Scalar-List-Utils 1.03 以降が インストールされているなら、以下のように出来ます:</p>

                            <pre class="prettyprint lang-perl"><code>        use List::Util &#39;shuffle&#39;;

        @shuffled = shuffle(@list);</code></pre>

                            <div class="original">

                                <p>If not, you can use a Fisher-Yates shuffle.</p>

                            </div>

                            <p>そうでないなら、Fisher-Yates 法が使えます。</p>

                            <pre class="prettyprint lang-perl"><code>        sub fisher_yates_shuffle {
                my $deck = shift;  # $deck is a reference to an array
                return unless @$deck; # must not be empty!

                my $i = @$deck;
                while (--$i) {
                        my $j = int rand ($i+1);
                        @$deck[$i,$j] = @$deck[$j,$i];
                        }
        }

        # shuffle my mpeg collection
        #
        my @mpeg = &lt;audio/*/*.mp3&gt;;
        fisher_yates_shuffle( \@mpeg );    # randomize @mpeg in place
        print @mpeg;</code></pre>

                            <div class="original">

                                <p>Note that the above implementation shuffles an array in place, unlike the <code>List::Util::shuffle()</code> which takes a list and returns a new shuffled list.</p>

                            </div>

                            <p><code>List::Util::shuffle()</code> はリストを受け取って、混ぜられた新しいリストを 返しますが、上記の実装は配列そのものを混ぜることに注意してください。</p>

                            <div class="original">

                                <p>You&#39;ve probably seen shuffling algorithms that work using splice, randomly picking another element to swap the current element with</p>

                            </div>

                            <p>splice を使ったシャッフルアルゴリズムを見たことがあるかもしれません。 カレントの要素をランダムに取り出した別の要素と交換します:</p>

                            <pre class="prettyprint lang-perl"><code>        srand;
        @new = ();
        @old = 1 .. 10;  # just a demo
        while (@old) {
                push(@new, splice(@old, rand @old, 1));
                }</code></pre>

                            <div class="original">

                                <p>This is bad because splice is already O(N), and since you do it N times, you just invented a quadratic algorithm; that is, O(N**2). This does not scale, although Perl is so efficient that you probably won&#39;t notice this until you have rather largish arrays.</p>

                            </div>

                            <p>これは splice が O(N) であり、さらにそれを N 回呼んでいるのですから 良くありません。 つまりこれは O(N**2) のアルゴリズムです。 これは大きな配列に使わなければあなたはその効率の悪さに気がつかないでしょう。</p>

                            <h2 id="How32do32I32process47modify32each32element32of32an32array63">配列の各要素に対する処理や、変更を行うには?<a href="#How32do32I32process47modify32each32element32of32an32array63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Use <code>for</code>/<code>foreach</code>:</p>

                            </div>

                            <p><code>for</code>/<code>foreach</code> を使います:</p>

                            <pre class="prettyprint lang-perl"><code>        for (@lines) {
                s/foo/bar/;     # change that word
                tr/XZ/ZX/;      # swap those letters
                }</code></pre>

                            <div class="original">

                                <p>Here&#39;s another; let&#39;s compute spherical volumes:</p>

                            </div>

                            <p>別の方法です; 球の体積を求めます:</p>

                            <pre class="prettyprint lang-perl"><code>        for (@volumes = @radii) {   # @volumes has changed parts
                $_ **= 3;
                $_ *= (4/3) * 3.14159;  # this will be constant folded
                }</code></pre>

                            <div class="original">

                                <p>which can also be done with <code>map()</code> which is made to transform one list into another:</p>

                            </div>

                            <p>リストを他のリストに変換する <code>map()</code> を使っても行えます:</p>

                            <pre class="prettyprint lang-perl"><code>        @volumes = map {$_ ** 3 * (4/3) * 3.14159} @radii;</code></pre>

                            <div class="original">

                                <p>If you want to do the same thing to modify the values of the hash, you can use the <code>values</code> function. As of Perl 5.6 the values are not copied, so if you modify $orbit (in this case), you modify the value.</p>

                            </div>

                            <p>同じことをハッシュの値に対して行いたいのであれば、<code>values</code> は使えません。 Perl 5.6 以降では値はコピーされないので、(この場合では) $orbit を変更すると、 値を変更することになります。</p>

                            <pre class="prettyprint lang-perl"><code>        for $orbit ( values %orbits ) {
                ($orbit **= 3) *= (4/3) * 3.14159;
                }</code></pre>

                            <div class="original">

                                <p>Prior to perl 5.6 <code>values</code> returned copies of the values, so older perl code often contains constructions such as <code>@orbits{keys %orbits}</code> instead of <code>values %orbits</code> where the hash is to be modified.</p>

                            </div>

                            <p>perl 5.6 以前では、<code>values</code> は値のコピーを返すので、古い perl の コードでは、ハッシュを修正しているところで <code>values %orbits</code> ではなく <code>@orbits{keys %orbits}</code> と書いていることがよくあります。</p>

                            <h2 id="How32do32I32select32a32random32element32from32an32array63">ある配列からランダムに要素を選択するには?<a href="#How32do32I32select32a32random32element32from32an32array63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Use the <code>rand()</code> function (see <a href="/pod/perlfunc#rand">&quot;rand&quot; in perlfunc</a>):</p>

                            </div>

                            <p><code>rand()</code> 関数を使います(<a href="/pod/perlfunc#rand">&quot;rand&quot; in perlfunc</a> を参照):</p>

                            <pre class="prettyprint lang-perl"><code>        $index   = rand @array;
        $element = $array[$index];</code></pre>

                            <div class="original">

                                <p>Or, simply:</p>

                            </div>

                            <p>あるいは、単純に:</p>

                            <pre class="prettyprint lang-perl"><code>        my $element = $array[ rand @array ];</code></pre>

                            <h2 id="How32do32I32permute32N32elements32of32a32list63">N 要素を持つリストの順列(permute)を求めるには?<a href="#How32do32I32permute32N32elements32of32a32list63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Use the <code>List::Permutor</code> module on CPAN. If the list is actually an array, try the <code>Algorithm::Permute</code> module (also on CPAN). It&#39;s written in XS code and is very efficient:</p>

                            </div>

                            <p>CPAN にある <code>List::Permutor</code> モジュールを使ってください。 リストが実際には配列なら、<code>Algorithm::Permute</code> モジュール(これも CPAN に あります)を試してください。 これは XS コードで書かれていて、とても効率的です:</p>

                            <pre class="prettyprint lang-perl"><code>        use Algorithm::Permute;

        my @array = &#39;a&#39;..&#39;d&#39;;
        my $p_iterator = Algorithm::Permute-&gt;new ( \@array );

        while (my @perm = $p_iterator-&gt;next) {
           print &quot;next permutation: (@perm)\n&quot;;
                }</code></pre>

                            <div class="original">

                                <p>For even faster execution, you could do:</p>

                            </div>

                            <p>より速い実行のために、以下のようにも出来ます:</p>

                            <pre class="prettyprint lang-perl"><code>        use Algorithm::Permute;

        my @array = &#39;a&#39;..&#39;d&#39;;

        Algorithm::Permute::permute {
                print &quot;next permutation: (@array)\n&quot;;
                } @array;</code></pre>

                            <div class="original">

                                <p>Here&#39;s a little program that generates all permutations of all the words on each line of input. The algorithm embodied in the <code>permute()</code> function is discussed in Volume 4 (still unpublished) of Knuth&#39;s <i>The Art of Computer Programming</i> and will work on any list:</p>

                            </div>

                            <p>以下の小さなプログラムは入力された行にある各単語の順列をすべて生成します。 関数 permute() で使われているアルゴリズムは Knuth の <i>The Art of Computer Programming</i> の Volume 4 (未発行) で 議論されていて、任意のリストで動作するはずです:</p>

                            <pre class="prettyprint lang-perl"><code>        #!/usr/bin/perl -n
        # Fischer-Krause ordered permutation generator

        sub permute (&amp;@) {
                my $code = shift;
                my @idx = 0..$#_;
                while ( $code-&gt;(@_[@idx]) ) {
                        my $p = $#idx;
                        --$p while $idx[$p-1] &gt; $idx[$p];
                        my $q = $p or return;
                        push @idx, reverse splice @idx, $p;
                        ++$q while $idx[$p-1] &gt; $idx[$q];
                        @idx[$p-1,$q]=@idx[$q,$p-1];
                }
        }

        permute { print &quot;@_\n&quot; } split;</code></pre>

                            <div class="original">

                                <p>The <code>Algorithm::Loops</code> module also provides the <code>NextPermute</code> and <code>NextPermuteNum</code> functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</p>

                            </div>

                            <p><code>Algorithm::Loops</code> モジュールも the <code>NextPermute</code> と <code>NextPermuteNum</code> の 関数を提供していて、重複した値が含まれていても、その場で変更して、配列の 全てのユニークな順列を探します: もしその要素が逆順にソートされているなら、配列を反転させて、ソートを 行い、偽を返します; さもなければ次の順列を返します。</p>

                            <div class="original">

                                <p><code>NextPermute</code> uses string order and <code>NextPermuteNum</code> numeric order, so you can enumerate all the permutations of <code>0..9</code> like this:</p>

                            </div>

                            <p><code>NextPermute</code> は文字列順を使い、<code>NextPermuteNum</code> は数値順を使うので、 <code>0..9</code> の全ての順番を数え上げるには以下のようにします:</p>

                            <pre class="prettyprint lang-perl"><code>        use Algorithm::Loops qw(NextPermuteNum);

    my @list= 0..9;
    do { print &quot;@list\n&quot; } while NextPermuteNum @list;</code></pre>

                            <h2 id="How32do32I32sort32an32array32by32anything41">(なにか)で配列をソートするには?<a href="#How32do32I32sort32an32array32by32anything41" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Supply a comparison function to sort() (described in <a href="/pod/perlfunc#sort">&quot;sort&quot; in perlfunc</a>):</p>

                            </div>

                            <p>sort() (<a href="/pod/perlfunc#sort">&quot;sort&quot; in perlfunc</a> に説明があります)のための比較関数を作ります:</p>

                            <pre class="prettyprint lang-perl"><code>        @list = sort { $a &lt;=&gt; $b } @list;</code></pre>

                            <div class="original">

                                <p>The default sort function is cmp, string comparison, which would sort <code>(1, 2, 10)</code> into <code>(1, 10, 2)</code>. <code>&lt;=&gt;</code>, used above, is the numerical comparison operator.</p>

                            </div>

                            <p>デフォルトのソート関数は文字列比較である cmp で、<code>(1, 2, 10)</code> を <code>(1, 10, 2)</code> に並び変えます。 上の例では、数値比較演算子である <code>&lt;=&gt;</code> を使っています。</p>

                            <div class="original">

                                <p>If you have a complicated function needed to pull out the part you want to sort on, then don&#39;t do it inside the sort function. Pull it out first, because the sort BLOCK can be called many times for the same element. Here&#39;s an example of how to pull out the first word after the first number on each item, and then sort those words case-insensitively.</p>

                            </div>

                            <p>ソートするものの一部を取り出す必要があるような複雑な関数を使うのなら、 ソート関数の内側でそれを使ってはいけません。 最初にその関数で使う部分を取り出します。 なぜなら、sort BLOCK は同じ要素に対して何度も何度も呼び出される 可能性があるからです。 以下の例は、各アイテムの最初の番号の後にある最初の単語を取り出し、 その後でそれらの単語を大小文字を無視してソートします。</p>

                            <pre class="prettyprint lang-perl"><code>        @idx = ();
        for (@data) {
                ($item) = /\d+\s*(\S+)/;
                push @idx, uc($item);
            }
        @sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];</code></pre>

                            <div class="original">

                                <p>which could also be written this way, using a trick that&#39;s come to be known as the Schwartzian Transform:</p>

                            </div>

                            <p>これはシュワルツ変換と呼ばれるトリックを使って以下のように 書くこともできます:</p>

                            <pre class="prettyprint lang-perl"><code>        @sorted = map  { $_-&gt;[0] }
                sort { $a-&gt;[1] cmp $b-&gt;[1] }
                map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @data;</code></pre>

                            <div class="original">

                                <p>If you need to sort on several fields, the following paradigm is useful.</p>

                            </div>

                            <p>幾つかのフィールドを使ってソートする必要があるのなら、 以下のやり方が便利でしょう。</p>

                            <pre class="prettyprint lang-perl"><code>        @sorted = sort {
                field1($a) &lt;=&gt; field1($b) ||
                field2($a) cmp field2($b) ||
                field3($a) cmp field3($b)
                } @data;</code></pre>

                            <div class="original">

                                <p>This can be conveniently combined with precalculation of keys as given above.</p>

                            </div>

                            <p>これは先の例にあったキーの precalculation と組み合わせることも できます。</p>

                            <div class="original">

                                <p>See the <i>sort</i> article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz for more about this approach.</p>

                            </div>

                            <p>この手法に関する更なる情報については http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz にある &quot;Far More Than You Ever Wanted To Know&quot; コレクションの <i>sort</i> という記事を 参照してください。</p>

                            <div class="original">

                                <p>See also the question later in <a href="/pod/perlfaq4">perlfaq4</a> on sorting hashes.</p>

                            </div>

                            <p><a href="/pod/perlfaq4">perlfaq4</a> で後述する、ハッシュのソートに関する質問も参照してください。</p>

                            <h2 id="How32do32I32manipulate32arrays32of32bits63">ビット配列を扱うには?<a href="#How32do32I32manipulate32arrays32of32bits63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Use <code>pack()</code> and <code>unpack()</code>, or else <code>vec()</code> and the bitwise operations.</p>

                            </div>

                            <p><code>pack()</code> と <code>unpack()</code> か、<code>vec()</code> とビット演算を使います。</p>

                            <div class="original">

                                <p>For example, you don&#39;t have to store individual bits in an array (which would mean that you&#39;re wasting a lot of space). To convert an array of bits to a string, use <code>vec()</code> to set the right bits. This sets <code>$vec</code> to have bit N set only if <code>$ints[N]</code> was set:</p>

                            </div>

                            <p>例えば、それぞれのビットを配列に格納する(これをすると多くのメモリが 無駄になります)必要はありません。 ビットの配列を文字列に変換するには、正しいビットをセットするのに <code>vec()</code> 使います。 これは、<code>$ints[N]</code> がセットされている場合のみ <code>$vec</code> の bit N を セットします。</p>

                            <pre class="prettyprint lang-perl"><code>        @ints = (...); # array of bits, e.g. ( 1, 0, 0, 1, 1, 0 ... )
        $vec = &#39;&#39;;
        foreach( 0 .. $#ints ) {
                vec($vec,$_,1) = 1 if $ints[$_];
                }</code></pre>

                            <div class="original">

                                <p>The string <code>$vec</code> only takes up as many bits as it needs. For instance, if you had 16 entries in <code>@ints</code>, <code>$vec</code> only needs two bytes to store them (not counting the scalar variable overhead).</p>

                            </div>

                            <p>文字列 <code>$vec</code> は必要なビット数だけを取ります。 例えば、<code>@ints</code> に 16 エントリがあるとすると、<code>$vec</code> はこれを 格納するのに (スカラ変数のオーバーヘッドを除いて) 2 バイトだけを 使います。</p>

                            <div class="original">

                                <p>Here&#39;s how, given a vector in <code>$vec</code>, you can get those bits into your <code>@ints</code> array:</p>

                            </div>

                            <p>次に挙げる例は、<code>$vec</code> で与えられるベクターのビットを配列 <code>@ints</code> に 取り出すものです:</p>

                            <pre class="prettyprint lang-perl"><code>        sub bitvec_to_list {
                my $vec = shift;
                my @ints;
                # Find null-byte density then select best algorithm
                if ($vec =~ tr/\0// / length $vec &gt; 0.95) {
                        use integer;
                        my $i;

                        # This method is faster with mostly null-bytes
                        while($vec =~ /[^\0]/g ) {
                                $i = -9 + 8 * pos $vec;
                                push @ints, $i if vec($vec, ++$i, 1);
                                push @ints, $i if vec($vec, ++$i, 1);
                                push @ints, $i if vec($vec, ++$i, 1);
                                push @ints, $i if vec($vec, ++$i, 1);
                                push @ints, $i if vec($vec, ++$i, 1);
                                push @ints, $i if vec($vec, ++$i, 1);
                                push @ints, $i if vec($vec, ++$i, 1);
                                push @ints, $i if vec($vec, ++$i, 1);
                                }
                        }
                else {
                        # This method is a fast general algorithm
                        use integer;
                        my $bits = unpack &quot;b*&quot;, $vec;
                        push @ints, 0 if $bits =~ s/^(\d)// &amp;&amp; $1;
                        push @ints, pos $bits while($bits =~ /1/g);
                        }

                return \@ints;
                }</code></pre>

                            <div class="original">

                                <p>This method gets faster the more sparse the bit vector is. (Courtesy of Tim Bunce and Winfried Koenig.)</p>

                            </div>

                            <p>この方法はビットベクターが疎であるときにさらに高速になります (Tim Bunce と Winfried Koenig によるものです)。</p>

                            <div class="original">

                                <p>You can make the while loop a lot shorter with this suggestion from Benjamin Goldberg:</p>

                            </div>

                            <p>Benjamin Goldberg の提案を使って、while ループをはるかに 短くすることもできます:</p>

                            <pre class="prettyprint lang-perl"><code>        while($vec =~ /[^\0]+/g ) {
                push @ints, grep vec($vec, $_, 1), $-[0] * 8 .. $+[0] * 8;
                }</code></pre>

                            <div class="original">

                                <p>Or use the CPAN module <code>Bit::Vector</code>:</p>

                            </div>

                            <p>または CPAN の <code>Bit::Vector</code> モジュールを使います:</p>

                            <pre class="prettyprint lang-perl"><code>        $vector = Bit::Vector-&gt;new($num_of_bits);
        $vector-&gt;Index_List_Store(@ints);
        @ints = $vector-&gt;Index_List_Read();</code></pre>

                            <div class="original">

                                <p><code>Bit::Vector</code> provides efficient methods for bit vector, sets of small integers and &quot;big int&quot; math.</p>

                            </div>

                            <p><code>Bit::Vector</code> は、ビットベクタ、小さい整数の就業、「大きな整数」の 計算に関する効果的なメソッドを提供します。</p>

                            <div class="original">

                                <p>Here&#39;s a more extensive illustration using vec():</p>

                            </div>

                            <p>以下は、vec() を使った広範囲な説明です:</p>

                            <pre class="prettyprint lang-perl"><code>        # vec demo
        $vector = &quot;\xff\x0f\xef\xfe&quot;;
        print &quot;Ilya&#39;s string \\xff\\x0f\\xef\\xfe represents the number &quot;,
        unpack(&quot;N&quot;, $vector), &quot;\n&quot;;
        $is_set = vec($vector, 23, 1);
        print &quot;Its 23rd bit is &quot;, $is_set ? &quot;set&quot; : &quot;clear&quot;, &quot;.\n&quot;;
        pvec($vector);

        set_vec(1,1,1);
        set_vec(3,1,1);
        set_vec(23,1,1);

        set_vec(3,1,3);
        set_vec(3,2,3);
        set_vec(3,4,3);
        set_vec(3,4,7);
        set_vec(3,8,3);
        set_vec(3,8,7);

        set_vec(0,32,17);
        set_vec(1,32,17);

        sub set_vec {
                my ($offset, $width, $value) = @_;
                my $vector = &#39;&#39;;
                vec($vector, $offset, $width) = $value;
                print &quot;offset=$offset width=$width value=$value\n&quot;;
                pvec($vector);
                }

        sub pvec {
                my $vector = shift;
                my $bits = unpack(&quot;b*&quot;, $vector);
                my $i = 0;
                my $BASE = 8;

                print &quot;vector length in bytes: &quot;, length($vector), &quot;\n&quot;;
                @bytes = unpack(&quot;A8&quot; x length($vector), $bits);
                print &quot;bits are: @bytes\n\n&quot;;
                }</code></pre>

                            <h2 id="Why32does32defined40return32true32on32empty32arrays32and32hashes63">なぜ空の配列やハッシュに defined() を使ったときに真が返ってくるのでしょう?<a href="#Why32does32defined40return32true32on32empty32arrays32and32hashes63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See <a href="/pod/perlfunc#defined">&quot;defined&quot; in perlfunc</a> in the 5.004 release or later of Perl for more detail.</p>

                            </div>

                            <p>簡単にいえば、スカラや関数に対してのみ defined を使うべきで、 集成体(aggregates, 配列やハッシュ)に対して使うべきではないのです。 詳しくは 5.004 以降の <a href="/pod/perlfunc#defined">&quot;defined&quot; in perlfunc</a> を参照してください。</p>

                            <h1 id="Data:32Hashes32Associative32Arrays41">データ: ハッシュ(連想配列)<a href="#Data:32Hashes32Associative32Arrays41" class="toc_link">&#182;</a></h1>

                            <p></p>

                            <h2 id="How32do32I32process32an32entire32hash63">ハッシュ全体を処理するには?<a href="#How32do32I32process32an32entire32hash63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>There are a couple of ways that you can process an entire hash. You can get a list of keys, then go through each key, or grab a one key-value pair at a time.</p>

                            </div>

                            <p>ハッシュ全体を処理するには二つの方法があります。 キーのリストを取得してからキー毎に処理するか、一度に一つのキー-値の ペアを取得するかです。</p>

                            <div class="original">

                                <p>To go through all of the keys, use the <code>keys</code> function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you&#39;re processing:</p>

                            </div>

                            <p>全てのキーを得るには、<code>keys</code> 関数を使います。 ハッシュの全てのキーを展開してリストの形で返します。 それから処理したい特定のキーの値を取得します。</p>

                            <pre class="prettyprint lang-perl"><code>        foreach my $key ( keys %hash ) {
                my $value = $hash{$key}
                ...
                }</code></pre>

                            <div class="original">

                                <p>Once you have the list of keys, you can process that list before you process the hash elements. For instance, you can sort the keys so you can process them in lexical order:</p>

                            </div>

                            <p>キーのリストを取得したら、ハッシュ要素を処理する前にリストを処理できます。 例えば、キーをソートしてレキシカルな順序で処理できます:</p>

                            <pre class="prettyprint lang-perl"><code>        foreach my $key ( sort keys %hash ) {
                my $value = $hash{$key}
                ...
                }</code></pre>

                            <div class="original">

                                <p>Or, you might want to only process some of the items. If you only want to deal with the keys that start with <code>text:</code>, you can select just those using <code>grep</code>:</p>

                            </div>

                            <p>あるいは、アイテムの一部に対してのみ処理したいかもしれません。 キーが <code>text:</code> で始まるキーのみ扱いたいなら、単に <code>grep</code> を使って 選択できます:</p>

                            <pre class="prettyprint lang-perl"><code>        foreach my $key ( grep /^text:/, keys %hash ) {
                my $value = $hash{$key}
                ...
                }</code></pre>

                            <div class="original">

                                <p>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using <code>each()</code>, which returns a pair you haven&#39;t seen yet:</p>

                            </div>

                            <p>ハッシュがとても大きい場合、キーの長いリストを作りたくないかもしれません。 メモリを節約するために、まだ取得していないキー-値の組を一つ返す <code>each()</code> を 使って組を取得できます:</p>

                            <pre class="prettyprint lang-perl"><code>        while( my( $key, $value ) = each( %hash ) ) {
                ...
                }</code></pre>

                            <div class="original">

                                <p>The <code>each</code> operator returns the pairs in apparently random order, so if ordering matters to you, you&#39;ll have to stick with the <code>keys</code> method.</p>

                            </div>

                            <p><code>each</code> 演算子は組を一見ランダムな順序で返すので、順序が問題になる場合は、 <code>keys</code> メソッドを使う必要があります。</p>

                            <div class="original">

                                <p>The <code>each()</code> operator can be a bit tricky though. You can&#39;t add or delete keys of the hash while you&#39;re using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you use <code>keys</code>, <code>values</code>, or <code>each</code> on the same hash, you can reset the iterator and mess up your processing. See the <code>each</code> entry in <a href="/pod/perlfunc">perlfunc</a> for more details.</p>

                            </div>

                            <p>しかし、<code>each()</code> 演算子は少しトリッキーです。 Perl が内部的に全ての要素を再ハッシュした後にいくつかの組をスキップしたり 再処理したりすることなく、ハッシュの使用中にハッシュのキーを追加したり 削除したりすることは出来ません。 さらに、一つのハッシュは一つのイテレータしか持っていないので、もし同じ ハッシュに対して <code>keys</code>, <code>values</code>, <code>each</code> を使うと、イテレータを リセットしてしまって処理が無茶苦茶になってしまいます。 さらなる詳細については <a href="/pod/perlfunc">perlfunc</a> の <code>each</code> エントリを参照してください。</p>

                            <h2 id="How32do32I32merge32two32hashes63">二つのハッシュをマージするには?<a href="#How32do32I32merge32two32hashes63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</p>

                            </div>

                            <p>二つのハッシュをマージしようと決める前に、もし両方のハッシュに 同じキーがあったときにどうするかと、元のハッシュをそのままに しておくかどうかを決める必要があります。</p>

                            <div class="original">

                                <p>If you want to preserve the original hashes, copy one hash (<code>%hash1</code>) to a new hash (<code>%new_hash</code>), then add the keys from the other hash (<code>%hash2</code> to the new hash. Checking that the key already exists in <code>%new_hash</code> gives you a chance to decide what to do with the duplicates:</p>

                            </div>

                            <p>もし元のハッシュを保存しておきたいなら、一つのハッシュ (<code>%hash1</code>) を 新しいハッシュ (<code>%new_hash</code>) にコピーして、それからもう一つのハッシュ (<code>%hash2</code>) からキーを新しいハッシュに追加します。 キーが既に <code>%new_hash</code> にある場合、重複をどうするかを決定する 機会が与えられます:</p>

                            <pre class="prettyprint lang-perl"><code>        my %new_hash = %hash1; # make a copy; leave %hash1 alone

        foreach my $key2 ( keys %hash2 )
                {
                if( exists $new_hash{$key2} )
                        {
                        warn &quot;Key [$key2] is in both hashes!&quot;;
                        # handle the duplicate (perhaps only warning)
                        ...
                        next;
                        }
                else
                        {
                        $new_hash{$key2} = $hash2{$key2};
                        }
                }</code></pre>

                            <div class="original">

                                <p>If you don&#39;t want to create a new hash, you can still use this looping technique; just change the <code>%new_hash</code> to <code>%hash1</code>.</p>

                            </div>

                            <p>新しいハッシュを作りたくない場合は、やはりこのループ技術が使えます; 単に <code>%new_hash</code> を <code>%hash1</code> に変更します。</p>

                            <pre class="prettyprint lang-perl"><code>        foreach my $key2 ( keys %hash2 )
                {
                if( exists $hash1{$key2} )
                        {
                        warn &quot;Key [$key2] is in both hashes!&quot;;
                        # handle the duplicate (perhaps only warning)
                        ...
                        next;
                        }
                else
                        {
                        $hash1{$key2} = $hash2{$key2};
                        }
                }</code></pre>

                            <div class="original">

                                <p>If you don&#39;t care that one hash overwrites keys and values from the other, you could just use a hash slice to add one hash to another. In this case, values from <code>%hash2</code> replace values from <code>%hash1</code> when they have keys in common:</p>

                            </div>

                            <p>片方のキーと値がもう片方で上書きされても気にしないなら、片方のハッシュから もう片方に追加するために単にハッシュスライスを使えます。 この場合、共通のキーがあった場合は、 <code>%hash1</code> の値は <code>%hash2</code> の値で置き換えられます:</p>

                            <pre class="prettyprint lang-perl"><code>        @hash1{ keys %hash2 } = values %hash2;</code></pre>

                            <h2 id="What32happens32if32I32add32or32remove32keys32from32a32hash32while32iterating32over32it63">ハッシュに対して反復操作を行っているときにキーの追加や削除をすると何が起きますか?<a href="#What32happens32if32I32add32or32remove32keys32from32a32hash32while32iterating32over32it63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>The easy answer is &quot;Don&#39;t do that!&quot;</p>

                            </div>

                            <p>簡単な答えは:「そんなことをするな！」</p>

                            <div class="original">

                                <p>If you iterate through the hash with each(), you can delete the key most recently returned without worrying about it. If you delete or add other keys, the iterator may skip or double up on them since perl may rearrange the hash table. See the entry for <code>each()</code> in <a href="/pod/perlfunc">perlfunc</a>.</p>

                            </div>

                            <p>ハッシュを each() で反復すると、それについて気にすることなく、 最後に返されたキーを削除できます。 他のキーを削除または追加すると、perl はハッシュテーブルを再構成するので、 反復子はキーを読み飛ばしたり重複して読んだりするかもしれません。 <a href="/pod/perlfunc">perlfunc</a> の <code>each()</code> のエントリを参照してください。</p>

                            <h2 id="How32do32I32look32up32a32hash32element32by32value63">ハッシュの要素をその値で検索するには?<a href="#How32do32I32look32up32a32hash32element32by32value63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Create a reverse hash:</p>

                            </div>

                            <p>リバースハッシュを作成します:</p>

                            <pre class="prettyprint lang-perl"><code>        %by_value = reverse %by_key;
        $key = $by_value{$value};</code></pre>

                            <div class="original">

                                <p>That&#39;s not particularly efficient. It would be more space-efficient to use:</p>

                            </div>

                            <p>これは特に効率がよいものではありません。 空間を効率よく使うにはこうします:</p>

                            <pre class="prettyprint lang-perl"><code>        while (($key, $value) = each %by_key) {
                $by_value{$value} = $key;
            }</code></pre>

                            <div class="original">

                                <p>If your hash could have repeated values, the methods above will only find one of the associated keys. This may or may not worry you. If it does worry you, you can always reverse the hash into a hash of arrays instead:</p>

                            </div>

                            <p>ハッシュに同じ値がある場合には、このメソッドは最初に見つかったキーだけを 見つけだします。 あなたはこれを気にするかも知れませんし、気にしないかもしれません。 もし気にするのなら、いつでもハッシュの代わりに配列のハッシュを 使うことができます:</p>

                            <pre class="prettyprint lang-perl"><code>        while (($key, $value) = each %by_key) {
                 push @{$key_list_by_value{$value}}, $key;
                }</code></pre>

                            <h2 id="How32can32I32know32how32many32entries32are32in32a32hash63">ハッシュにどれくらいの要素があるのを知るには?<a href="#How32can32I32know32how32many32entries32are32in32a32hash63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>This is very similar to &quot;How do I process an entire hash?&quot;, also in <a href="/pod/perlfaq4">perlfaq4</a>, but a bit simpler in the common cases.</p>

                            </div>

                            <p>これは <a href="/pod/perlfaq4">perlfaq4</a> の &quot;How do I process an entire hash?&quot; と とてもよく似ていますが、一般的な場合では少し単純になります。</p>

                            <div class="original">

                                <p>You can use the <code>keys()</code> built-in function in scalar context to find out have many entries you have in a hash:</p>

                            </div>

                            <p>ハッシュにいくつのエントリがあるかを知るために、スカラコンテキストで <code>keys()</code> 組み込み関数を使えます:</p>

                            <pre class="prettyprint lang-perl"><code>        my $key_count = keys %hash; # must be scalar context!</code></pre>

                            <div class="original">

                                <p>If you want to find out how many entries have a defined value, that&#39;s a bit different. You have to check each value. A <code>grep</code> is handy:</p>

                            </div>

                            <p>定義された値のエントリの数を知りたい場合は、少し異なります。 それぞれの値をチェックする必要があります。 <code>grep</code> が手軽です:</p>

                            <pre class="prettyprint lang-perl"><code>        my $defined_value_count = grep { defined } values %hash;</code></pre>

                            <div class="original">

                                <p>You can use that same structure to count the entries any way that you like. If you want the count of the keys with vowels in them, you just test for that instead:</p>

                            </div>

                            <p>ある特定の条件を持つエントリを数える場合には全て同じ構造が使えます。 もしキーに母音が含まれているエントリを数えたい場合、そのように テストを置き換えるだけです:</p>

                            <pre class="prettyprint lang-perl"><code>        my $vowel_count = grep { /[aeiou]/ } keys %hash;</code></pre>

                            <div class="original">

                                <p>The <code>grep</code> in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</p>

                            </div>

                            <p>スカラコンテキストの <code>grep</code> は数を返します。 マッチングしたアイテムのリストがほしい場合は、代わりにリストコンテキストで 使うだけです:</p>

                            <pre class="prettyprint lang-perl"><code>        my @defined_values = grep { defined } values %hash;</code></pre>

                            <div class="original">

                                <p>The <code>keys()</code> function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as <code>each()</code>.</p>

                            </div>

                            <p><code>keys()</code> 関数も反復動作を初期化するので、もしこれを <code>each()</code> のような 他のハッシュ演算子を使っている間に使うと、おかしな結果になります。</p>

                            <h2 id="How32do32I32sort32a32hash32optionally32by32value32instead32of32key41">ハッシュを(キーではなく値で)ソートするには?<a href="#How32do32I32sort32a32hash32optionally32by32value32instead32of32key41" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>To sort a hash, start with the keys. In this example, we give the list of keys to the sort function which then compares them ASCIIbetically (which might be affected by your locale settings). The output list has the keys in ASCIIbetical order. Once we have the keys, we can go through them to create a report which lists the keys in ASCIIbetical order.</p>

                            </div>

                            <p>ハッシュをソートするために、キーから始めます。 この例では、キーのリストをソート関数に渡して、それから ASCII 順で比較します (ロケール設定の影響を受けるかもしれません)。 出力リストは ASCII 順のキーのリストです。 キーを得たら、ASCII 順にキーを並べたレポートを作成します。</p>

                            <pre class="prettyprint lang-perl"><code>        my @keys = sort { $a cmp $b } keys %hash;

        foreach my $key ( @keys )
                {
                printf &quot;%-20s %6d\n&quot;, $key, $hash{$key};
                }</code></pre>

                            <div class="original">

                                <p>We could get more fancy in the <code>sort()</code> block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</p>

                            </div>

                            <p>しかし、<code>sort()</code> ブロックでもっと面白いことができます。 キーを比較する代わりに、これらの値を計算してその値を比較に使います。</p>

                            <div class="original">

                                <p>For instance, to make our report order case-insensitive, we use the <code>\L</code> sequence in a double-quoted string to make everything lowercase. The <code>sort()</code> block then compares the lowercased values to determine in which order to put the keys.</p>

                            </div>

                            <p>例えば、大文字小文字を無視した順序のレポートを作るには、全てを小文字に するためにダブルクォートされた文字列の中で <code>\L</code> シーケンスが使えます。 それから <code>sort()</code> ブロックがキーを出力する順番を決定するために小文字化された 値を比較します。</p>

                            <pre class="prettyprint lang-perl"><code>        my @keys = sort { &quot;\L$a&quot; cmp &quot;\L$b&quot; } keys %hash;</code></pre>

                            <div class="original">

                                <p>Note: if the computation is expensive or the hash has many elements, you may want to look at the Schwartzian Transform to cache the computation results.</p>

                            </div>

                            <p>注意: 計算が高くつくものであったり、ハッシュがたくさんの要素を持っている 場合、計算結果をキャッシュするためにシュワルツ変換を使いたいかもしれません。</p>

                            <div class="original">

                                <p>If we want to sort by the hash value instead, we use the hash key to look it up. We still get out a list of keys, but this time they are ordered by their value.</p>

                            </div>

                            <p>もし代わりにハッシュの値でソートしたいなら、それを探すためにハッシュキーを 使います。 やはりキーのリストを使いますが、今度はその値でソートします。</p>

                            <pre class="prettyprint lang-perl"><code>        my @keys = sort { $hash{$a} &lt;=&gt; $hash{$b} } keys %hash;</code></pre>

                            <div class="original">

                                <p>From there we can get more complex. If the hash values are the same, we can provide a secondary sort on the hash key.</p>

                            </div>

                            <p>ここから、より複雑なものにできます。 ハッシュ値が同じ場合は、ハッシュキーによる第二段階のソートを提供できます。</p>

                            <pre class="prettyprint lang-perl"><code>        my @keys = sort {
                $hash{$a} &lt;=&gt; $hash{$b}
                        or
                &quot;\L$a&quot; cmp &quot;\L$b&quot;
                } keys %hash;</code></pre>

                            <h2 id="How32can32I32always32keep32my32hash32sorted63">私のハッシュを常にソートされた状態にしておくには?<a href="#How32can32I32always32keep32my32hash32sorted63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>You can look into using the <code>DB_File</code> module and <code>tie()</code> using the <code>$DB_BTREE</code> hash bindings as documented in <a href="/pod/DB_File#In32Memory32Databases">&quot;In Memory Databases&quot; in DB_File</a>. The <code>Tie::IxHash</code> module from CPAN might also be instructive. Although this does keep your hash sorted, you might not like the slow down you suffer from the tie interface. Are you sure you need to do this? :)</p>

                            </div>

                            <p><a href="/pod/DB_File#In32Memory32Databases">&quot;In Memory Databases&quot; in DB_File</a> にあるように、<code>DB_File</code> モジュールと <code>tie()</code> を使った、$DB_BTREE ハッシュ束縛を使うことができます。 CPAN の <code>Tie::IxHash</code> モジュールも有益かもしれません。 これによりハッシュはソートされた状態のままになりますが、tie インターフェースによって被る速度低下を気に入らないかもしれません。 あなたは本当にこれが必要ですか? :)</p>

                            <h2 id="Whats32the32difference32between32delete32and32undef32with32hashes63">ハッシュに対する "delete" と "undef"との間の違いは?<a href="#Whats32the32difference32between32delete32and32undef32with32hashes63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>Hashes contain pairs of scalars: the first is the key, the second is the value. The key will be coerced to a string, although the value can be any kind of scalar: string, number, or reference. If a key <code>$key</code> is present in %hash, <code>exists($hash{$key})</code> will return true. The value for a given key can be <code>undef</code>, in which case <code>$hash{$key}</code> will be <code>undef</code> while <code>exists $hash{$key}</code> will return true. This corresponds to (<code>$key</code>, <code>undef</code>) being in the hash.</p>

                            </div>

                            <p>ハッシュはスカラのペアからなります: 最初のスカラがキーで、 二番目のスカラが値です。 キーは文字列、数値、リファレンスのいずれの種類のスカラであっても 強制的に文字列にされます。 %hash の中に <code>$key</code> というキーが既にあれば、<code>exists($hash{$key})</code> は 真を返します。 与えられたキーに対する値は <code>undef</code> とすることができます。 これは <code>$hash{$key}</code> を <code>undef</code> にして、<code>exists $hash{$key}</code> が真を 返すという状態です。 これは (<code>$key</code>, <code>undef</code>)がハッシュに存在しているということを示しています。</p>

                            <div class="original">

                                <p>Pictures help... here&#39;s the <code>%hash</code> table:</p>

                            </div>

                            <p>図が助けになるでしょう。 以下は <code>%hash</code> のテーブルです:</p>

                            <pre class="prettyprint lang-perl"><code>          keys  values
        +------+------+
        |  a   |  3   |
        |  x   |  7   |
        |  d   |  0   |
        |  e   |  2   |
        +------+------+</code></pre>

                            <div class="original">

                                <p>And these conditions hold</p>

                            </div>

                            <p>そしてこれらが保持している状態はこうです:</p>

                            <pre class="prettyprint lang-perl"><code>        $hash{&#39;a&#39;}                       is true
        $hash{&#39;d&#39;}                       is false
        defined $hash{&#39;d&#39;}               is true
        defined $hash{&#39;a&#39;}               is true
        exists $hash{&#39;a&#39;}                is true (Perl 5 only)
        grep ($_ eq &#39;a&#39;, keys %hash)     is true</code></pre>

                            <div class="original">

                                <p>If you now say</p>

                            </div>

                            <p>ここで</p>

                            <pre class="prettyprint lang-perl"><code>        undef $hash{&#39;a&#39;}</code></pre>

                            <div class="original">

                                <p>your table now reads:</p>

                            </div>

                            <p>とすると、テーブルはこうなります:</p>

                            <pre class="prettyprint lang-perl"><code>          keys  values
        +------+------+
        |  a   | undef|
        |  x   |  7   |
        |  d   |  0   |
        |  e   |  2   |
        +------+------+</code></pre>

                            <div class="original">

                                <p>and these conditions now hold; changes in caps:</p>

                            </div>

                            <p>そしてその状態は以下のようになります。 大文字になっているのが変わった場所です:</p>

                            <pre class="prettyprint lang-perl"><code>        $hash{&#39;a&#39;}                       is FALSE
        $hash{&#39;d&#39;}                       is false
        defined $hash{&#39;d&#39;}               is true
        defined $hash{&#39;a&#39;}               is FALSE
        exists $hash{&#39;a&#39;}                is true (Perl 5 only)
        grep ($_ eq &#39;a&#39;, keys %hash)     is true</code></pre>

                            <div class="original">

                                <p>Notice the last two: you have an undef value, but a defined key!</p>

                            </div>

                            <p>最後の二つに注目してください: あなたは undef 値を保持していますが、 キーは define されているのです!</p>

                            <div class="original">

                                <p>Now, consider this:</p>

                            </div>

                            <p>さて、こんどは以下の例を考えてみましょう:</p>

                            <pre class="prettyprint lang-perl"><code>        delete $hash{&#39;a&#39;}</code></pre>

                            <div class="original">

                                <p>your table now reads:</p>

                            </div>

                            <p>テーブルはこうなります:</p>

                            <pre class="prettyprint lang-perl"><code>          keys  values
        +------+------+
        |  x   |  7   |
        |  d   |  0   |
        |  e   |  2   |
        +------+------+</code></pre>

                            <div class="original">

                                <p>and these conditions now hold; changes in caps:</p>

                            </div>

                            <p>そしてその状態はこうです。大文字の部分が変わったところです:</p>

                            <pre class="prettyprint lang-perl"><code>        $hash{&#39;a&#39;}                       is false
        $hash{&#39;d&#39;}                       is false
        defined $hash{&#39;d&#39;}               is true
        defined $hash{&#39;a&#39;}               is false
        exists $hash{&#39;a&#39;}                is FALSE (Perl 5 only)
        grep ($_ eq &#39;a&#39;, keys %hash)     is FALSE</code></pre>

                            <div class="original">

                                <p>See, the whole entry is gone!</p>

                            </div>

                            <p>ほら、エントリが丸ごとなくなっていまいました!</p>

                            <h2 id="Why32dont32my32tied32hashes32make32the32defined47exists32distinction63">なぜわたしの tie されたハッシュは defined と exists を区別しないのでしょうか?<a href="#Why32dont32my32tied32hashes32make32the32defined47exists32distinction63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>This depends on the tied hash&#39;s implementation of EXISTS(). For example, there isn&#39;t the concept of undef with hashes that are tied to DBM* files. It also means that exists() and defined() do the same thing with a DBM* file, and what they end up doing is not what they do with ordinary hashes.</p>

                            </div>

                            <p>これは tie されたハッシュの EXISTS() の実装に依存します。 たとえば、DBM* ファイルに tie されたハッシュには undef という考え方はありません。 これはまた DBM* ファイルにとっては exists() と defined() とは同じことであり、 そういったものに対して行っていることは 通常のハッシュに対して行っていることとは違うのだということなのです。</p>

                            <h2 id="How32do32I32reset32an32each40operation32part-way32through63">each() 操作の途中でリセットしてしまうには?<a href="#How32do32I32reset32an32each40operation32part-way32through63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>(contributed by brian d foy)</p>

                            </div>

                            <p>(brian d foy によって寄贈されました)</p>

                            <div class="original">

                                <p>You can use the <code>keys</code> or <code>values</code> functions to reset <code>each</code>. To simply reset the iterator used by <code>each</code> without doing anything else, use one of them in void context:</p>

                            </div>

                            <p><code>each</code> をリセットするために <code>keys</code> 関数か <code>values</code> 関数が使えます。 他に何もせずに単に <code>each</code> で使われているイテレータをリセットするには、 これらの一つを無効コンテキストで使います:</p>

                            <pre class="prettyprint lang-perl"><code>        keys %hash; # resets iterator, nothing else.
        values %hash; # resets iterator, nothing else.</code></pre>

                            <div class="original">

                                <p>See the documentation for <code>each</code> in <a href="/pod/perlfunc">perlfunc</a>.</p>

                            </div>

                            <p><a href="/pod/perlfunc">perlfunc</a> にある <code>each</code> の説明を参照してください。</p>

                            <h2 id="How32can32I32get32the32unique32keys32from32two32hashes63">二つのハッシュからユニークなキーを取りだすには?<a href="#How32can32I32get32the32unique32keys32from32two32hashes63" class="toc_link">&#182;</a></h2>

                            <p></p>

                            <div class="original">

                                <p>First you extract the keys from the hashes into lists, then solve the &quot;removing duplicates&quot; problem described above. For example:</p>

                            </div>

                            <p>まず最初にハッシュからキーを取りだして、それをリストに格納します。 そして、先に説明した「重複の削除」問題の解決を行います。例:</p>

                            <pre class="prettyprint lang-perl"><code>        %seen = ();
        for $element (keys(%foo), keys(%bar)) {
                $seen{$element}++;
                }
        @uniq = keys %seen;</code></pre>

                            <div class="original">

                                <p>Or more succinctly:</p>

                            </div>

                            <p>あるいはもっと簡潔に:</p>

                            <pre class="prettyprint lang-perl"><code>        @uniq = keys %{{%foo,%bar}};</code></pre>

                            <div class="original">

                                <p>Or if you really want to save space:</p>

                            </div>

                            <p>もし本当にメモリ空間を節約したいのなら:</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>

